ECE124
======

Digital circuits and systems.

    Instructor: Andrew Kennings
    Website: http://sifaka.uwaterloo.ca/~akenning/courses/ece124/

$$
\newcommand{\set}[1]{\left\{ #1 \right\}}
\newcommand{\tup}[1]{\left\langle #1 \right\rangle}
\newcommand{\abs}[1]{\left\lvert #1 \right\rvert}
\newcommand{\floor}[1]{\left\lfloor #1 \right\rfloor}
\newcommand{\mb}[1]{\mathbb{#1}}
\newcommand{\rem}{\operatorname{rem}}
\newcommand{\sign}{\operatorname{sign}}
\newcommand{\imag}{\boldsymbol{i}}
\newcommand{\dee}{\mathop{}\!\mathrm{d}}
\newcommand{\lH}{\overset{\text{l'H}}{=}}
\newcommand{\evalat}[1]{\left.\left(#1\right)\right|}
\newcommand{\sech}{\operatorname{sech}}
\newcommand{\spn}{\operatorname{Span}}
\newcommand{\proj}{\operatorname{proj}}
\newcommand{\prp}{\operatorname{perp}}
\newcommand{\refl}{\operatorname{refl}}
\newcommand{\magn}[1]{\left\lVert #1 \right\rVert}
\newcommand{\rank}{\operatorname{rank}}
\newcommand{\sys}[2]{\left[ #1 \mid #2\hskip2pt \right]}
\newcommand{\range}{\operatorname{Range}}
\newcommand{\adj}{\operatorname{adj}}
\newcommand{\cof}{\operatorname{cof}}
\newcommand{\diag}{\operatorname{diag}}
\newcommand{\formlp}{\operatorname{Form}(\mathcal{L}_P)}
$$

# 5/1/15

The assignments and other course resources can be found on the course website. They will not be posted to LEARN.

Boolean Algebra
---------------

See the CS245 notes for description of Boolean algebra.

Binary functions are defined using a truth table, or a Boolean logic formula. An example of a binary function is $f = f(x, y)$. Problem with truth tables is that they're big, and hard to manipulate.

Boolean AND is represented with $x \cdot y$, $xy$, or $x \wedge y$. The schematic symbol for this operation is a rectangle with one side completely rounded into a semicircle with the output wire, and the other flat and with input wires.

Boolean OR is represented with $x + y$. The schematic symbol for this operation is a rectangle with one side completely rounded into a semicircle with the output wire, with the other side curved inward and has input wires leading into it.

Boolean NOT is represented with $\overline x$, $!x$, $x'$, or $\neg x$. The schematic symbol for this operation is a triangle with a circle on the pointed end, which has the output wire, and the input wire is on the other end.

There is also an order of operations for these operations. From highest precedence to lowest, the operators are NOT, AND, and OR.

# 7/1/15

Minterms/Maxterms
-----------------

A **minterm** is a particular Boolean expression for a particular input to an $n$-input function. The minterm is special because it is easy to construct algorithmically from a truth table.

The minterm $m_i$ of a truth table's row $i$ is the an OR expression with an operand for each function input where each operand is $x_i$ if $x_i = 1$ for that row and $\neg x_i$ if $x_i = 0$.

Given a truth table, we can construct an expression that is equivalent to the function it represents as follows:

1. Create an empty expression $m$.
2. For each row $x_0, \ldots, x_n, f$ in the truth table:
  1. Create an empty expression $m_i$.
  2. For all $1 \le i \le n$:
    1. If $x_i = 0$, let $m_i$ become $m_i \cdot \neg x_i$.
    2. If $x_i = 1$, let $m_i$ become $m_i \cdot x_i$.
  3. If and only if $f = 1$, let $m$ become $m \vee m_i$. Note that $m_i$ is true if and only if the inputs match those in the current row of the truth table.
3. Note that $m$ is true if and only if $f = 1$, since there is an $m_i$ term for all the rows in the truth table that are true, and none of them match any rows in the truth table that are not true.

Here, each $m_i$ is a minterm. $m$ is the sum of minterms/canonical sum of products, defined below.

The **canonical sum of products/sum of minterms** is when we OR all the minterms ($m_i$) that have $f = 1$ for their corresponding truth table rows, in order.

The **maxterms** of a function are the duals of the minterms - similar to the minterms, but with AND instead of OR, and $\neg x$ and $x$ where we used to have $x$ and $\neg x$.

The maxterm $M_i$ of a truth table's row $i$ is the an OR expression with an operand for each function input where each operand is $x_i$ if $x_i = 1$ for that row and $\neg x_i$ if $x_i = 0$.

The maxterm is true if and only if the inputs _do not match the inputs in the corresponding row in the truth table_. This is the opposite of a minterm being true if and only if the inputs do match the inputs.

The **canonical product of sums/product of maxterms** is when we AND all the maxterms that have $f = 0$ for their corresponding truth table rows, in order. In other words, it is an expression that ensures that the inputs do not match the first row resulting in 0, and do not match the second row resulting in 0, and so on.

The sum of minterms and product of maxterms are special because it is exactly equivalent to the original function. The term **canonical** means that they are unique - there is only one way to write it correctly.

Minterms determine when we need to turn the function on. Maxterms determine when we need to turn the function off.

A $n$-level expression is an expression that has a maximum tree depth of $n$. $xy + z$ is a 2-level expression, and when we draw the circuit, it has 2 levels of gates - the depth of the circuit tree. The level of a circuit is the length of the longest path from a circuit input to an output.

For example, if a 2-input function has the following truth table:

| x | y | f |
|:--|:--|:--|
| 0 | 0 | 1 |
| 0 | 1 | 0 |
| 1 | 0 | 0 |
| 1 | 1 | 1 |

The minterms are $\neg x \neg y$ and $x y$, and the maxterms are $x \neg y$ and $\neg x y$. As a result, we can write $f$ as $\neg x \neg y + x y$ (sum of minterms) or $(x + \neg y)(\neg x + y)$ (product of maxterms).

Our goal is to use the simplest possible circuits. We can choose whether to use the sum of minterms or product of maxterms, but we can also use Boolean algebra to further simplify any expression.

Boolean Algebra
---------------

Axioms of Boolean algebra:

1. Closure over operations: given $x, y \in \set{0, 1}$, $x \cdot y, x + y, \neg x \in \set{0, 1}$.
2. Operation identities: given $x \in \set{0, 1}$, $x + 0 = x$ and $x \cdot 1 = x$. $0$ is the OR identity and $1$ is the AND identity.
3. Commutativity: given $x, y \in \set{0, 1}$, $x + y = y + x$ and $x \cdot y = y \cdot x$.
4. Distributivity: $x + y \cdot z = (x + y) \cdot (x + z)$ (distributivity over OR) and $x \cdot (y + z) = x \cdot y + x \cdot z$.
5. Negation existance: given $x \in \set{0, 1}$, there must exist an element $\neg x$ such that $x + \neg x = 1$ and $x \cdot \neg x = 0$.
6. Unique elements: there must exist $x, y \in \set{0, 1}$ such that $x \ne y$.

We can now prove theorems using truth tables, or using axioms:

Additional theorems:

1. $x + x = x$ and $x \cdot x = x$
2. $x + 1 = 1$ and $x \cdot 0 = 0$
3. $\neg \neg x = x$ (double negation)
4. $x + (y + z) = (x + y) + z$ and $x \cdot (y \cdot z) = (x \cdot y) \cdot z$ (associativity)
5. $\neg (x + y) = \neg x \cdot \neg y$ and $\neg (x \cdot y) = \neg x + \neg y$ (De Morgan's Law)
6. $x + x \cdot y = x$ and $x \cdot (x + y) = x$ (adsorption)

# 9/1/15

Simplify $\overline{\overline{cd} + a} + a + cd + ab$:

> $$
\begin{align*}
\overline{\overline{cd} + a} + a + cd + ab &= \overline{\overline{c}}d\overline{a} + a + cd + ab = cd\overline{a} + a + cd + ab \\
&= cd(\overline{a} + 1) + a + ab = cd + a + ab = cd + a(1 + b) = cd + a
\end{align*}
$$  
> Note that this is still a **sum of products** (SOP), although it isn't necessarily unique. A product of sums (POS) is what we would get if we worked with maxterms. A sum of products is always a 2-level circuit.  

We can use Boolean algebra to convert the sum of minterms or product of maxterms into a simplified expression. This allows us to convert a truth table into a sinple Boolean expression.

We can also represent a sum of minterms like $m_{a_1} + \ldots + m_{a_n}$ using the shorthand notation $\sum(a_1, \ldots, a_n)$. For example, $f = m_3 + m_5 + m_6 + m_7$ can also be written as $\sum(3, 5, 6, 7)$.

Likewise, maxterms have a shorthand as well: $M_{a_1} + \ldots + M_{a_n}$ can be written as $\prod(a_1, \ldots, a_n)$.

Each logical operation has a physical cost when we build the circuit in real life. For now, each gate costs 1 unit, each gate input costs 1 unit, and the inverters at inputs are free. For example, $xy + yz$ has a 2-input OR, and two 2-input ANDs, so it has a cost of $(1 + 2) + 2 \cdot (1 + 2) = 9$.

To convert between a sum of products and a product of sums, invert it twice and apply De Morgan's laws. For example, let $f = \sum(1, 4, 7)$:

> Clearly, $f = m_1 + m_4 + m_7 = \overline{\overline{f}}$.  
> Clearly, $\overline{f} = m_0 + m_2 + m_3 + m_5 + m_6$, the minterms that are not part of the function.  
> So $f = \overline{m_0 + m_2 + m_3 + m_5 + m_6} = \overline{m_0}\overline{m_2}\overline{m_3}\overline{m_5}\overline{m_6}$, by De Morgan's laws.  
> Note that $\overline{m_i} = M_i$ - a maxterm is the negation of its corresponding minterm.  
> So $f = \overline{m_0}\overline{m_2}\overline{m_3}\overline{m_5}\overline{m_6} = M_0 M_2 M_3 M_5 M_6$, a product of sums, as required.  

# 12/1/15

Other Logic Gates
-----------------

The NAND gate is an AND gate with an inverted output, written $x \uparrow y$. The NOR gate is an OR gate with an inverted output, written $x \downarrow y$.

When we invert an input or an output, we can just put a hollow small bubble/circle inline with the wire, conventionally touching the gate.

Note that NAND and NOR are not associative, so two NAND/NOR gates chained together is different from a three-input NAND/NOR gate.

These gates are extremely useful for circuits built using technology such as CMOS. In CMOS, the cheapest construct is the NAND gate, so we tend to make other constructs in terms of NAND gates.

However, we generally want to work with normal gates like AND and OR, and convert it into NAND at the end. Since NAND and NOR are universal, any combinatorial circuit can be represented using just one of these gates.

To convert sums of products into NAND logic, simply negate the whole thing twice and apply De Morgan's law. For example, $f = a \overline b + \overline b + c = \overline{\overline f} = \overline{\overline{a \overline b} \overline{\overline a b} \overline c}$, and the final result is all NAND gates. This can also be done recursively on subexpressions. This also works for converting products of sums into NOR logic.

Alternatively, we can also just replace each individual gate with its NAND equivalent. For reference, $x + y = (x \uparrow x) \uparrow (y \uparrow y)$, $xy = (x \uparrow y) \uparrow (x \uparrow y)$, and $\overline x = x \uparrow x$.

This also works graphically. In a circuit schematic, simply insert two back-to-back inverters inline to wires, until it is possible to see NAND forms. By moving one of a pair of inserted inverters into the output for an AND gate, for example, we can replace the AND and NOT with a NAND gate.

Essentially, we first insert pairs of inverters until all gates have been converted into NAND, then remove any remaining back-to-back inverters (since they cancel each other out) and replace any remaining single inverters with their NAND forms.

# 13/1/15

Boolean XOR is represented with $x \oplus y$. The schematic symbol for this operation is an OR gate, but with the concave side having two lines. It has the same precedence in Boolean algebra as the AND gate.

Boolean XOR essentially is true if and only if there are an odd number of operands that are true. For two inputs this is useful as an inequality operator $\ne$.

$x \oplus y = \overline x y + x \overline y$. This pattern appears quite often in practical Boolean algebra, and so using XOR can often simplify formulas quite a bit. Plus, in technologies like CMOS, XOR can be implemented significantly cheaper than its long, SOP form, so we can save on cost too by using this.

Boolean NXOR (also known as XNOR) is simply XOR inverted. For two inputs this is useful as an equality operator $=$.

A **buffer** is a special identity gate, $f = x$, which has the same output as it does input. It has the same symbol as the inverter, but without the circle at the output.

This is useful for amplifying signals and supplying current when there are a lot of branches. Additionally, it can act as a diode (in 3-level logic) when placed in a real circuit. Plus, sometimes we use it for slowing down a signal slightly to improve timing synchronocity. Mathematically, it does not serve any purpose.

A tri-state buffer is similar, but has another input called Enable coming out of one side. When the Enable wire is high, the output is the same as the input. When enable is low, the output is disconnected from the input - the value of the output is not specified.

Tri-state buffers are useful if we want to connect multiple sources to the same destination. For example, in RAM we might have one per RAM cell, and selectively connect and disconnect the RAM cell such that only one cell is actually connected to the destination at a given time. This is important, since if we have two RAM cells connected at the same time, one with 0's and one with 1's, there would be a short circuit.

Karnaugh Maps
-------------

Karnaugh maps (K-maps) are a way of describing Boolean functions with around 5 or less inputs (for larger inputs, it becomes impractical, as the number of table cells grows with $2^n$).

K-maps are also useful because they can be used to minimise functions by graphically performing Boolean algebra.

Consider K-map for the function $f = \overline x \overline y + \overine x y + x y$:

| $y$\$x$ | 0 | 1 |
|:--------|:--|:--|
| **0**   | 1 | 0 |
| **1**   | 1 | 1 |

Note that each normal box (rectangle) corresponds to a row in the truth table for the function, and each 1 in a normal box corresponds to a minterm.

Note that the bottom two are both 1. That means that the value of $x$ does not influence the bottom row, so we can draw a rectangle around the bottom two, which represents $y$.

Note that we can do the same for the leftmost row of two 1's, a rectangle around the two representing $\overline x$.

If we want to minimise a function, the goal of K-mapping is to find the smallest possible number of the largest possible rectangles that cover all the 1 boxes and do not cover any 0 boxes (floating boxes don't matter). In each step, we try to draw a rectangle that encloses as many 1's as possible without enclosing any 0's.

This implies that there may be multiple optimal minimal versions of the function, with the same cost. This is represented by multiple minimal rectangle possibilities in the table, or multiple factoring possibilities in the Boolean expression

All rectangles must have side lengths that are powers of 2.

Mathematically, when we draw a rectangle we are duplicating a term and then factoring an input out. The boxes we drew above corresponded to the operations $f = \overline x \overline y + \overline x y + xy = \overline x \overline y + \overline x y + xy + \overline x y = \overline x(\overline y + y) + y(x + \overline x) = \overline x + y$.

Basically, every rectangle duplicates and factors two terms, repeatedly for larger rectangles. This is the reason rectangles need to have dimensions that are powers of 2. Larger rectangles result in products with fewer factors. Fewer rectangles result in fewer products.

The above technique resulted in a sum of products. To get a product of sums, draw maximum rectangles that cover all 0's but no 1's. Rather than a product, each rectangle has a corresponding sum, made up of the inverted inputs that actually matter in making the function 0.

For example, if there is a 0 at $x_1 = 0, x_2 = 0, x_3 = 1, x_4 = 1$, the rectangle surrounding just that 0 is associated with $x_1 + x_2 + \overline{x_3} + \overline{x_4}$. The minimized product of sums is simply the product of the sum associated with each rectangle.

Also, the sides are labelled using grey code, and the rectangles can wrap around the sides of the table.

# 14/1/15

When doing K-maps, we can read off the answer from the rectangles by looking at which variables did not change within the minterms in a given rectangle. If all the minterms in a rectangle have $x_1$ equal to 0, but all other variables may change, then the rectangle represents the term $\overline x_1$.

If we look at the table and see that no rectangles can be expanded, that means that in the Boolean expression, there is no more factoring or collapsing left to be done.

For K-maps of larger dimensions, we label the rows and columns using grey code - a binary counting system in which only one bit changes when incrementing or decrementing a value. The grey code is recursively defined. The 1-bit grey code is `grey_code(1) = [0, 1]`. The $n$-bit grey code is `grey_code[n] = map(grey_code[n - 1], lambda code: 0 .. code) + map(reversed(grey_code[n - 1]), lambda code: 1 .. code)`.

In other words, to get the next grey code, we prepend a 0 to every binary string in the current grey code, and prepend a 1 to the reversed version of the current grey code, then put these two together.

Every variable splits the output space of a function in half. Let $f(x_1, \ldots, x_n)$ be a Boolean function. Let $f_0$ represent $f(0, x_2, \ldots, x_n)$ and $f_1$ represent $f(1, x_2, \ldots, x_n)$.

# 16/1/15

### More Dimensions

The 5-input K-map is 3-dimensional. This is because the rectangles in 2D can only factor up to 2 variables per dimension.

As a result, it is difficult to visualize. Instead, what we can do is $f = \overline x f_0 + x f_1$, and then do one K-map for $f_0$ and one for $f_1$ side by side. This represents a 4 by 4 by 2 cuboid. Now, instead of finding rectangles, we find cuboids - we can join rectangles that are adjacent across their K-map, but also between the two K-maps:


| $x_3 x_4$\$x_1 x_2, x_5 = 0$ | 00 | 01 | 11 | 10 |
|:-----------------------------|:---|:---|:---|:---|
| **00**                       | 1  | 0  | 0  | 1  |
| **01**                       | 0  | 1  | 1  | 0  |
| **11**                       | 0  | 1  | 1  | 0  |
| **10**                       | 0  | 1  | 0  | 0  |

| $x_3 x_4$\$x_1 x_2$ $x_5 = 1$ | 00 | 01 | 11 | 10 |
|:------------------------------|:---|:---|:---|:---|
| **00**                        | 1  | 0  | 0  | 1  |
| **01**                        | 0  | 1  | 1  | 0  |
| **11**                        | 0  | 1  | 1  | 1  |
| **10**                        | 0  | 1  | 0  | 1  |

There is a 2x2x2 cuboid at the middle, a 2x1x2 cuboid at the top corners, a 1x2x1 cuboid at the right side of the right K-map, and a 1x2x2 cuboid at the second-to-leftmost row at the bottom of the tables. This corresponds to the terms $x_2 x_4$, $\overline{x_2} \overline{x_3} \overline{x_4}$, $x_1 \overline{x_2} x_3 x_5$, $\overline{x_1} x_2 x_3$.

Potentially, we could also do 6 variable maps by making 4 4-input K-maps, but this is much more difficult to visualize.

### Extensions

Sometimes, the output of a function doesn't matter, like when we have inputs that will never occur. When this is the case, we can say that the value of the function is a **don't care**. In truth tables and other situations, this is represented as "x". The don't cares are part of the specifications of a circuit.

For example, suppose we have a binary to decimal converter, a circuit that accepts 4 inputs and 10 outputs that interprets the 4 inputs as a 4-bit binary number and turns on 1 of the 10 inputs depending on the binary value of the input being between 0 and 9 inclusive. In this case, we can assume that the input binary value will never be above 9, since the circuit wouldn't work then anyways, and all the outputs for those inputs would be don't cares.

In a K-map, we can include don't cares in rectangles if we want to, but it's not required - we can include them in rectangles if it helps us make rectangles larger, but we can leave don't cares outside of rectangles if they don't help.

The minimized function resulting from the K-map is functionally equivalent - both implementations do what we want them to - but they might not be logically equivalent, when we use don't cares.

When we want to minimise a function with multiple outputs, we could try to minimise each output individually as functions with only one output, but this is not necessarily the lowest cost circuit, since there are a lot of logical signals that get duplicated.

In the K-map, this translates to sometimes not expanding rectangles when it is possible to. Sometimes, with multiple sums of products, the best overall solution is one where the individual sums of products are not necessarily best.

Essentially, we can sometimes do **product term sharing** to lower overall cost when multiple SOPs use the same ones. We can sometimes do this in Boolean algebra by factoring to find common products.

Finding the best overall solution is a problem known as multiple output minimization, and is an NP-hard problem.

### Math Background

A product term $a$ **covers** a product term $b$ if and only if $b = 1 \implies a = 1$.

A product term is an **implicant** of a function $f$ if and only if $f = 1$ for all minterms covered by the product term - all the minterms that the product term covers are those that correspond to truth table rows that are 1. In a K-map, an implicant is a rectangle of 1's and possibly don't cares.

A  **prime implicant** is an implicant in which no variable can be removed without making it a non-implicant - it is an implicant that cannot be simplified by removing variables. In a K-map, these are the largest possible rectangles of 1's.

# 19/1/15

An **essential prime implicant** is a prime implicant that covers a minterm that is not in any other prime implicant.

Functions implemented with prime implicants tend to be cheaper, since the AND gates have as few inputs as possible, and the bigger the area an implicant covers, the less other 1's we need to include. As a result, the minimum sum of products is an implementation of the function using as few prime implicants as possible, and each one as large as possible.

Every function can be implemented as a set of prime implicants, all OR'd together. We must include all the essential prime implicants, but we might also have prime implicants that would be prime if they didn't overlap. We must therefore choose rectangles from the remaining non-essential implicants such that we cover all the 1's, with as few rectangles as possible.

CMOS
----

CMOS is one of the most popular technologies around for implementing logic gates. In CMOS, the cheapest 2-input gates are NAND and NOR, which uses the fewest transistors possible. The two types of transistors in CMOS are NMOS and PMOS.

### NMOS

An **NMOS** (N-channel MOSFET) has a source $S$ (often connected to a lower voltage), a drain $D$ (often connected to a higher voltage), and a gate $G$ (which controls the current flowing from the drain to the source):

![NMOS Transistor](data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyA/Pgo8IS0tQ3JlYXRlZCBieSB3ZWJ0cm9uaWNzIDAuMS0tPgo8c3ZnIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgd2lkdGg9IjYwIiBoZWlnaHQ9IjYxLjQyMTg3NDA0NjMyNTY4NCI+PHJlY3QgeD0iMCIgeT0iMCIgZmlsbD0id2hpdGUiIHdpZHRoPSI2MHB4IiBoZWlnaHQ9IjYxLjQyMTg3NDA0NjMyNTY4NHB4Ii8+PGcgY29ubmVjdHM9IjAsMjA7MzAsMDszMCw0MCIgc3Ryb2tlPSJibGFjayIgc3Ryb2tlLXdpZHRoPSIycHgiIGlkPSJtIiBjbGFzcz0ibm1vc2ZldCIgZmxpcHBhYmxlPSJ0cnVlIiB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDEwLDEwKSI+CjxtZXRhZGF0YSBjbGFzcz0icGFydCI+Cjx3dHg6cGFydCB4bWxuczp3dHg9Imh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vcC93ZWJ0cm9uaWNzIj4KICAgIDx3dHg6cGlucz4KICAgICAgICA8d3R4OmFuYWxvZz4KPCEtLXBpbiBvcmRlciBpcyBkcmFpbiBnYXRlIHNvdXJjZSBzdWJzdHJhdGUgCnN1YnN0cmF0ZSBpcyBjb25uZWN0ZWQgdG8gc291cmNlLS0+CgkgICAgPHd0eDpub2RlIGluZGV4PSIxIiB4PSIzMCIgeT0iMCIvPgogICAgICAgICAgICA8d3R4Om5vZGUgaW5kZXg9IjIiIHg9IjAiIHk9IjIwIi8+CiAgICAgICAgICAgIDx3dHg6bm9kZSBpbmRleD0iMyIgeD0iMzAiIHk9IjQwIi8+CiAgICAgICAgICAgIDx3dHg6bm9kZSBpbmRleD0iNCIgeD0iMzAiIHk9IjQwIi8+CiAgICAgICAgPC93dHg6YW5hbG9nPgogICAgPC93dHg6cGlucz4KICAgIDx3dHg6aWQ+bTwvd3R4OmlkPgogICAgPHd0eDp0eXBlPm08L3d0eDp0eXBlPgogICAgPHd0eDpuYW1lPm5tb3NmZXQ8L3d0eDpuYW1lPgogICAgPHd0eDpjYXRlZ29yeT50cmFuc2lzdG9yczwvd3R4OmNhdGVnb3J5PgogICAgPHd0eDp2YWx1ZS8+CiAgICA8d3R4OmxhYmVsLz4KICAgIDx3dHg6c3BpY2UvPgogICAgPHd0eDpmbGlwPnRydWU8L3d0eDpmbGlwPgogICAgPHd0eDptb2RlbC8+Cjwvd3R4OnBhcnQ+CjwvbWV0YWRhdGE+ICA8cmVjdCBpZD0icmVjdDIxNjIiIHZpc2liaWxpdHk9ImhpZGRlbiIgaGVpZ2h0PSI0MCIgd2lkdGg9IjQwIiB5PSIwIiB4PSIwIiBmaWxsPSJub25lIi8+CiAgPHBhdGggaWQ9InBhdGgyMzk4IiBmaWxsPSJub25lIiBkPSJNMTkuODc3LDEyLjA4eiIvPgogIDx0ZXh0IGlkPSJ0ZXh0MjgyMyIgZm9udC1zaXplPSI4LjE5MDMxMjM5cHgiIGZvbnQtZmFtaWx5PSJCaXRzdHJlYW0gVmVyYSBTYW5zIiB5PSIxOC4xMTM3OTQiIHg9IjEuMDc4NjQ2MiIgc3Ryb2tlLXdpZHRoPSIwcHgiIGZvbnQtc3R5bGU9Im5vcm1hbCIgZmlsbD0iYmxhY2siPkc8L3RleHQ+CiAgPHRleHQgaWQ9InRleHQyODI3IiBmb250LXNpemU9IjguMDAwODMxNnB4IiBmb250LWZhbWlseT0iQml0c3RyZWFtIFZlcmEgU2FucyIgeT0iNy40MjA4MzIyIiB4PSIzMi4wNzI3MjEiIHN0cm9rZS13aWR0aD0iMHB4IiBmb250LXN0eWxlPSJub3JtYWwiIGZpbGw9ImJsYWNrIj5EPC90ZXh0PgogIDx0ZXh0IGlkPSJ0ZXh0MjgzMSIgZm9udC1zaXplPSI4LjA0ODQ1NzE1cHgiIGZvbnQtZmFtaWx5PSJCaXRzdHJlYW0gVmVyYSBTYW5zIiB5PSIzOS40MTQ5NzgiIHg9IjMyLjMzMzQ4NyIgc3Ryb2tlLXdpZHRoPSIwcHgiIGZvbnQtc3R5bGU9Im5vcm1hbCIgZmlsbD0iYmxhY2siPlM8L3RleHQ+CiAgPHBhdGggaWQ9InBhdGgyODkxIiBkPSJtMjAsMTIuOTI1LDEwLDAsMC0xMyIgZmlsbD0ibm9uZSIvPgogIDxwYXRoIGlkPSJwYXRoMjkzNCIgZD0ibTIwLDI2LjkyNSwxMCwwLDAsMTMiIGZpbGw9Im5vbmUiLz4KICA8cGF0aCBpZD0icGF0aDI5MzYiIGQ9Im0yMCwxOS45MjUsMTAsMCwwLDciIGZpbGw9Im5vbmUiLz4KICA8cGF0aCBpZD0icGF0aDI5MzgiIGQ9Im0yMCwxNi45MjUsMCw2IiBmaWxsPSJub25lIi8+CiAgPHBhdGggaWQ9InBhdGgyOTQyIiBkPSJtMjAsMjMuOTI1LDAsNiIgZmlsbD0ibm9uZSIvPgogIDxwYXRoIGlkPSJwYXRoMjk0NCIgZD0iTTIwLDE1LjkyNSwyMCw5LjkyNTUiIGZpbGw9Im5vbmUiLz4KICA8cGF0aCBpZD0icGF0aDI5NDYiIGQ9Ik0xNyw5LjkyNTUsMTcsMjkuOTI1IiBmaWxsPSJub25lIi8+CiAgPHBhdGggaWQ9InBhdGgyOTQ4IiBkPSJtMTcsMTkuOTI1LTE3LDAiIGZpbGw9Im5vbmUiLz4KIDxwYXRoIGlkPSJwYXRoMzgxMyIgZD0ibTIxLDE5LjkyNSwzLTIsMCw0LTMtMnoiIGZpbGw9Im5vbmUiLz4KPC9nPjwvc3ZnPg==)

Another common schematic symbol for an NMOS is a $\pi$-shape (with straight legs) with a bar on top connected to the gate, where the legs of the $\pi$ are the source and drain.

If we set the gate voltage $V_G$ to a voltage greater than some threshold voltage $V_T$ (like 2V, for example), so $V_G > V_T$, the NMOS just acts like a short circuit between the drain and the ground (the drain is "pulled down" to ground). If we we set it to ground (0V), the NMOS just acts like an open circuit between the drain and the source.

Basically, **an NMOS is a tri-state buffer, with input 1 that works best on the low side**, with the drain being the input, the source being the output, and the gate being the enable pin.

### PMOS

A **PMOS** (P-channel MOSFET) has a source (often connected to a higher voltage), a drain (often connected to a lower voltage), and a gate (which controls the current flowing from the drain to the source).

![PMOS Transistor](data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyA/Pgo8IS0tQ3JlYXRlZCBieSB3ZWJ0cm9uaWNzIDAuMS0tPgo8c3ZnIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgd2lkdGg9IjYwIiBoZWlnaHQ9IjYxLjQyMTg3NDA0NjMyNTY4NCI+PHJlY3QgeD0iMCIgeT0iMCIgZmlsbD0id2hpdGUiIHdpZHRoPSI2MHB4IiBoZWlnaHQ9IjYxLjQyMTg3NDA0NjMyNTY4NHB4Ii8+PGcgc3Ryb2tlPSJibGFjayIgc3Ryb2tlLXdpZHRoPSIycHgiIGlkPSJtIiBjbGFzcz0icG1vc2ZldCIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSwxMCwxMCkiPgo8bWV0YWRhdGEgY2xhc3M9InBhcnQiPgo8d3R4OnBhcnQgeG1sbnM6d3R4PSJodHRwOi8vY29kZS5nb29nbGUuY29tL3Avd2VidHJvbmljcyI+CiAgICA8d3R4OnBpbnM+CiAgICAgICAgPHd0eDphbmFsb2c+CjwhLS1waW4gb3JkZXIgaXMgZ2F0ZSBkcmFpbiBzb3VyY2Ugc3Vic3RyYXRlIApzdWJzdHJhdGUgaXMgY29ubmVjdGVkIHRvIHNvdXJjZS0tPgogICAgICAgICAgICA8d3R4Om5vZGUgaW5kZXg9IjEiIHg9IjMwIiB5PSIwIi8+CiAgICAgICAgICAgIDx3dHg6bm9kZSBpbmRleD0iMiIgeD0iMCIgeT0iMjAiLz4KICAgICAgICAgICAgPHd0eDpub2RlIGluZGV4PSIzIiB4PSIzMCIgeT0iNDAiLz4KICAgICAgICAgICAgPHd0eDpub2RlIGluZGV4PSI0IiB4PSIzMCIgeT0iNDAiLz4KICAgICAgICA8L3d0eDphbmFsb2c+CiAgICA8L3d0eDpwaW5zPgogICAgPHd0eDppZD5tPC93dHg6aWQ+CiAgICA8d3R4OnR5cGU+bTwvd3R4OnR5cGU+CiAgICA8d3R4Om5hbWU+cG1vc2ZldDwvd3R4Om5hbWU+CiAgICA8d3R4OmNhdGVnb3J5PnRyYW5zaXN0b3JzPC93dHg6Y2F0ZWdvcnk+CiAgICA8d3R4OnZhbHVlLz4KICAgIDx3dHg6bGFiZWwvPgogICAgPHd0eDpzcGljZS8+CiAgICA8d3R4OmZsaXA+dHJ1ZTwvd3R4OmZsaXA+CiAgICA8d3R4Om1vZGVsLz4KPC93dHg6cGFydD4KPC9tZXRhZGF0YT4JPHJlY3QgaWQ9InJlY3QyMTYyIiBoZWlnaHQ9IjQwIiB3aWR0aD0iNDAiIHk9IjAiIHg9IjAiIHZpc2liaWxpdHk9ImhpZGRlbiIgZmlsbD0ibm9uZSIvPgogIDxyZWN0IGlkPSJyZWN0MjE2MiIgdmlzaWJpbGl0eT0iaGlkZGVuIiBoZWlnaHQ9IjQwIiB3aWR0aD0iNDAiIHk9IjAiIHg9IjAiIGZpbGw9Im5vbmUiLz4KICA8cGF0aCBpZD0icGF0aDIzOTgiIGZpbGw9Im5vbmUiIGQ9Ik0xOS44NzcsMTIuMDh6Ii8+CiAgPHRleHQgaWQ9InRleHQyODIzIiBmb250LXNpemU9IjguMTkwMzEyMzlweCIgZm9udC1mYW1pbHk9IkJpdHN0cmVhbSBWZXJhIFNhbnMiIHk9IjE4LjExMzc5NCIgeD0iMS4wNzg2NDYyIiBzdHJva2Utd2lkdGg9IjBweCIgZm9udC1zdHlsZT0ibm9ybWFsIiBmaWxsPSJibGFjayI+RzwvdGV4dD4KICA8dGV4dCBpZD0idGV4dDI4MjciIGZvbnQtc2l6ZT0iOC4wMDA4MzE2cHgiIGZvbnQtZmFtaWx5PSJCaXRzdHJlYW0gVmVyYSBTYW5zIiB5PSI3LjQyMDgzMjIiIHg9IjMyLjA3MjcyMSIgc3Ryb2tlLXdpZHRoPSIwcHgiIGZvbnQtc3R5bGU9Im5vcm1hbCIgZmlsbD0iYmxhY2siPkQ8L3RleHQ+CiAgPHRleHQgaWQ9InRleHQyODMxIiBmb250LXNpemU9IjguMDQ4NDU3MTVweCIgZm9udC1mYW1pbHk9IkJpdHN0cmVhbSBWZXJhIFNhbnMiIHk9IjM5LjQxNDk3OCIgeD0iMzIuMzMzNDg3IiBzdHJva2Utd2lkdGg9IjBweCIgZm9udC1zdHlsZT0ibm9ybWFsIiBmaWxsPSJibGFjayI+UzwvdGV4dD4KICA8cGF0aCBpZD0icGF0aDI4OTEiIGQ9Im0yMCwxMi45MjUsMTAsMCwwLTEzIiBmaWxsPSJub25lIi8+CiAgPHBhdGggaWQ9InBhdGgyOTM0IiBkPSJtMjAsMjYuOTI1LDEwLDAsMCwxMyIgZmlsbD0ibm9uZSIvPgogIDxwYXRoIGlkPSJwYXRoMjkzNiIgZD0ibTIwLDE5LjkyNSwxMCwwLDAsNyIgZmlsbD0ibm9uZSIvPgogIDxwYXRoIGlkPSJwYXRoMjkzOCIgZD0ibTIwLDE2LjkyNSwwLDYiIGZpbGw9Im5vbmUiLz4KICA8cGF0aCBpZD0icGF0aDI5NDIiIGQ9Im0yMCwyMy45MjUsMCw2IiBmaWxsPSJub25lIi8+CiAgPHBhdGggaWQ9InBhdGgyOTQ0IiBkPSJNMjAsMTUuOTI1LDIwLDkuOTI1NSIgZmlsbD0ibm9uZSIvPgogIDxwYXRoIGlkPSJwYXRoMjk0NiIgZD0iTTE3LDkuOTI1NSwxNywyOS45MjUiIGZpbGw9Im5vbmUiLz4KICA8cGF0aCBpZD0icGF0aDI5NDgiIGQ9Im0xNywxOS45MjUtMTcsMCIgZmlsbD0ibm9uZSIvPgoKICA8cGF0aCBpZD0icGF0aDI5NTIiIGQ9Im0yNiwxNy45MjUsMywyLTMsMiwwLTR6IiBmaWxsPSJub25lIi8+CgogIDwvZz48L3N2Zz4=)

Another common schematic symbol for a PMOS is a $\pi$-shape (with straight legs) with a bar on top connected to the gate by a bubble (like an inverting bubble on the input), where the legs of the $\pi$ are the source and drain. This is the same as the alternate symbol for the NMOS, but with a bubble on the gate input.

If $V_G - V_S < -V_T$ (source-gate voltage lower than threshold), the PMOS acts like a short circuit between the source and the drain. If $V_G = V_S$, then the PMOS acts like an open circuit between the source and the drain.

Basically, **a PMOS is a tri-state buffer with input 1, that works best on the high side**, with source being the input, the drain being the output, and the enable pin being the inverted value of the gate.

### CMOS Logic

We can implement a NOT gate very simply using NMOS and PMOS:

![NOT gate](data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyA/Pgo8IS0tQ3JlYXRlZCBieSB3ZWJ0cm9uaWNzIDAuMS0tPgo8c3ZnIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgd2lkdGg9IjE2NS4xNDA2MjUiIGhlaWdodD0iMTQ3LjUiPjxyZWN0IHg9IjAiIHk9IjAiIGZpbGw9IndoaXRlIiB3aWR0aD0iMTY1LjE0MDYyNXB4IiBoZWlnaHQ9IjE0Ny41cHgiLz48ZyBjb25uZWN0cz0iMTAsMjAiIHN0cm9rZT0iYmxhY2siIHN0cm9rZS13aWR0aD0iMnB4IiBpZD0id2lyZSIgY2xhc3M9Im5hbWV3aXJlIiB0cmFuc2Zvcm09Im1hdHJpeCgwLjk5OTk5OTk5OTk5OTk5OTksMCwwLDAuOTk5OTk5OTk5OTk5OTk5OSw4OS45OTk5OTk5OTk5OTk4OSwxOS45OTk5OTk5OTk5OTk4ODYpIj4KPG1ldGFkYXRhIGNsYXNzPSJwYXJ0Ij4KPHd0eDpwYXJ0IHhtbG5zOnd0eD0iaHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL3dlYnRyb25pY3MiPgogICAgPHd0eDpwaW5zPgogICAgICAgIDx3dHg6YW5hbG9nPgogICAgICAgICAgICA8d3R4Om5vZGUgaW5kZXg9IjEiIHg9IjEwIiB5PSIyMCIvPgogICAgICAgIDwvd3R4OmFuYWxvZz4KICAgIDwvd3R4OnBpbnM+CiAgICA8d3R4OmlkPndpcmU8L3d0eDppZD4KICAgIDx3dHg6dHlwZT53aXJlPC93dHg6dHlwZT4KICAgIDx3dHg6bmFtZT5uYW1ld2lyZTwvd3R4Om5hbWU+CiAgICA8d3R4OmNhdGVnb3J5PnBvd2VyPC93dHg6Y2F0ZWdvcnk+CiAgICA8d3R4OnZhbHVlLz4KICAgIDx3dHg6bGFiZWwvPgogICAgPHd0eDpzcGljZS8+CiAgICA8d3R4OmZsaXAvPgogICAgPHd0eDptb2RlbC8+Cjwvd3R4OnBhcnQ+CjwvbWV0YWRhdGE+CiAgICA8cmVjdCB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHg9IjAiIHk9IjAiIGlkPSJyZWN0MjE2MiIgdmlzaWJpbGl0eT0iaGlkZGVuIi8+CiAgICA8cGF0aCBkPSJNIDkuODQ1MzU1NywwLjc1MTU1MTMyIEwgOS43ODg5ODYxLDIwLjAyNjA5IiBpZD0icGF0aDM2OTQiLz4KICAgIDxwYXRoIGQ9Ik0gNi44OTg0MDk1LDYuMDQwMDU2NyBMIDkuNzc2Njc5LDAuNjU4MzY3NDMgTCAxMy4xMTYxNTUsNS45MjE0Njc1IiBpZD0icGF0aDUwODkiLz4KCiAgPC9nPjxnIGNvbm5lY3RzPSIxMCwwIiBzdHJva2U9ImJsYWNrIiBzdHJva2Utd2lkdGg9IjJweCIgaWQ9IkduZCIgY2xhc3M9Imdyb3VuZCIgdHJhbnNmb3JtPSJtYXRyaXgoMC45OTk5OTk5OTk5OTk5OTk5LDAsMCwwLjk5OTk5OTk5OTk5OTk5OTksODkuOTk5OTk5OTk5OTk5ODksMTE5Ljk5OTk5OTk5OTk5OTg5KSI+CjxtZXRhZGF0YT4KPHd0eDpwYXJ0IHhtbG5zOnd0eD0iaHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL3dlYnRyb25pY3MiPgogICAgPHd0eDpwaW5zPgogICAgICAgIDx3dHg6YW5hbG9nPgogICAgICAgICAgICA8d3R4Om5vZGUgaW5kZXg9IjEiIHg9IjEwIiB5PSIwIi8+CiAgICAgICAgPC93dHg6YW5hbG9nPgogICAgPC93dHg6cGlucz4KICAgIDx3dHg6aWQ+Z25kPC93dHg6aWQ+CiAgICA8d3R4OnR5cGU+Z25kPC93dHg6dHlwZT4KICAgIDx3dHg6bmFtZT5ncm91bmQ8L3d0eDpuYW1lPgogICAgPHd0eDpjYXRlZ29yeT5wb3dlcjwvd3R4OmNhdGVnb3J5PgogICAgPHd0eDpmbGlwLz4KICAgIDx3dHg6dmFsdWUvPgogICAgPHd0eDpsYWJlbC8+CiAgICA8d3R4OnNwaWNlLz4KICAgIDx3dHg6bW9kZWwvPgo8L3d0eDpwYXJ0Pgo8L21ldGFkYXRhPgoKICAgIDxwYXRoIGQ9Ik0gMTAsMCBMIDEwLDExIiBpZD0icGF0aDM2OTQiLz4KICAgIDxwYXRoIGQ9Ik0gMC41MDAwMDAwNiwxMS44MzQxNTMgTCAxOS42NzEyNzUsMTEuODM0MTUzIiBpZD0icGF0aDM2OTYiLz4KICAgIDxwYXRoIGQ9Ik0gMi42NDgwODIzLDE0LjUgTCAxNy43MzI4ODEsMTQuNSIgaWQ9InBhdGgzNjk4Ii8+CiAgICA8cGF0aCBkPSJNIDUuODAyODczLDE3LjUgTCAxNC42NDgwODIsMTcuNSIgaWQ9InBhdGgzNzAwIi8+CiAgPC9nPjxjaXJjbGUgY3g9IjY5Ljk5OTk5OTk5OTk5OTk0IiBjeT0iODAiIHI9IjMiIHN0cm9rZT0iYmxhY2siIGZpbGw9ImJsYWNrIi8+PGcgY29ubmVjdHM9IjAsMjA7MzAsMDszMCw0MCIgc3Ryb2tlPSJibGFjayIgc3Ryb2tlLXdpZHRoPSIycHgiIGlkPSJtIiBjbGFzcz0ibm1vc2ZldCIgZmxpcHBhYmxlPSJ0cnVlIiB0cmFuc2Zvcm09Im1hdHJpeCgwLjk5OTk5OTk5OTk5OTk5OTksMCwwLDAuOTk5OTk5OTk5OTk5OTk5OSw2OS45OTk5OTk5OTk5OTk4OSw3OS45OTk5OTk5OTk5OTk4OSkiPgo8bWV0YWRhdGEgY2xhc3M9InBhcnQiPgo8d3R4OnBhcnQgeG1sbnM6d3R4PSJodHRwOi8vY29kZS5nb29nbGUuY29tL3Avd2VidHJvbmljcyI+CiAgICA8d3R4OnBpbnM+CiAgICAgICAgPHd0eDphbmFsb2c+CjwhLS1waW4gb3JkZXIgaXMgZHJhaW4gZ2F0ZSBzb3VyY2Ugc3Vic3RyYXRlIApzdWJzdHJhdGUgaXMgY29ubmVjdGVkIHRvIHNvdXJjZS0tPgoJICAgIDx3dHg6bm9kZSBpbmRleD0iMSIgeD0iMzAiIHk9IjAiLz4KICAgICAgICAgICAgPHd0eDpub2RlIGluZGV4PSIyIiB4PSIwIiB5PSIyMCIvPgogICAgICAgICAgICA8d3R4Om5vZGUgaW5kZXg9IjMiIHg9IjMwIiB5PSI0MCIvPgogICAgICAgICAgICA8d3R4Om5vZGUgaW5kZXg9IjQiIHg9IjMwIiB5PSI0MCIvPgogICAgICAgIDwvd3R4OmFuYWxvZz4KICAgIDwvd3R4OnBpbnM+CiAgICA8d3R4OmlkPm08L3d0eDppZD4KICAgIDx3dHg6dHlwZT5tPC93dHg6dHlwZT4KICAgIDx3dHg6bmFtZT5ubW9zZmV0PC93dHg6bmFtZT4KICAgIDx3dHg6Y2F0ZWdvcnk+dHJhbnNpc3RvcnM8L3d0eDpjYXRlZ29yeT4KICAgIDx3dHg6dmFsdWUvPgogICAgPHd0eDpsYWJlbC8+CiAgICA8d3R4OnNwaWNlLz4KICAgIDx3dHg6ZmxpcD50cnVlPC93dHg6ZmxpcD4KICAgIDx3dHg6bW9kZWwvPgo8L3d0eDpwYXJ0Pgo8L21ldGFkYXRhPiAgPHJlY3QgaWQ9InJlY3QyMTYyIiB2aXNpYmlsaXR5PSJoaWRkZW4iIGhlaWdodD0iNDAiIHdpZHRoPSI0MCIgeT0iMCIgeD0iMCIgZmlsbD0ibm9uZSIvPgogIDxwYXRoIGlkPSJwYXRoMjM5OCIgZmlsbD0ibm9uZSIgZD0iTTE5Ljg3NywxMi4wOHoiLz4KICA8dGV4dCBpZD0idGV4dDI4MjMiIGZvbnQtc2l6ZT0iOC4xOTAzMTIzOXB4IiBmb250LWZhbWlseT0iQml0c3RyZWFtIFZlcmEgU2FucyIgeT0iMTguMTEzNzk0IiB4PSIxLjA3ODY0NjIiIHN0cm9rZS13aWR0aD0iMHB4IiBmb250LXN0eWxlPSJub3JtYWwiIGZpbGw9ImJsYWNrIj5HPC90ZXh0PgogIDx0ZXh0IGlkPSJ0ZXh0MjgyNyIgZm9udC1zaXplPSI4LjAwMDgzMTZweCIgZm9udC1mYW1pbHk9IkJpdHN0cmVhbSBWZXJhIFNhbnMiIHk9IjcuNDIwODMyMiIgeD0iMzIuMDcyNzIxIiBzdHJva2Utd2lkdGg9IjBweCIgZm9udC1zdHlsZT0ibm9ybWFsIiBmaWxsPSJibGFjayI+RDwvdGV4dD4KICA8dGV4dCBpZD0idGV4dDI4MzEiIGZvbnQtc2l6ZT0iOC4wNDg0NTcxNXB4IiBmb250LWZhbWlseT0iQml0c3RyZWFtIFZlcmEgU2FucyIgeT0iMzkuNDE0OTc4IiB4PSIzMi4zMzM0ODciIHN0cm9rZS13aWR0aD0iMHB4IiBmb250LXN0eWxlPSJub3JtYWwiIGZpbGw9ImJsYWNrIj5TPC90ZXh0PgogIDxwYXRoIGlkPSJwYXRoMjg5MSIgZD0ibTIwLDEyLjkyNSwxMCwwLDAtMTMiIGZpbGw9Im5vbmUiLz4KICA8cGF0aCBpZD0icGF0aDI5MzQiIGQ9Im0yMCwyNi45MjUsMTAsMCwwLDEzIiBmaWxsPSJub25lIi8+CiAgPHBhdGggaWQ9InBhdGgyOTM2IiBkPSJtMjAsMTkuOTI1LDEwLDAsMCw3IiBmaWxsPSJub25lIi8+CiAgPHBhdGggaWQ9InBhdGgyOTM4IiBkPSJtMjAsMTYuOTI1LDAsNiIgZmlsbD0ibm9uZSIvPgogIDxwYXRoIGlkPSJwYXRoMjk0MiIgZD0ibTIwLDIzLjkyNSwwLDYiIGZpbGw9Im5vbmUiLz4KICA8cGF0aCBpZD0icGF0aDI5NDQiIGQ9Ik0yMCwxNS45MjUsMjAsOS45MjU1IiBmaWxsPSJub25lIi8+CiAgPHBhdGggaWQ9InBhdGgyOTQ2IiBkPSJNMTcsOS45MjU1LDE3LDI5LjkyNSIgZmlsbD0ibm9uZSIvPgogIDxwYXRoIGlkPSJwYXRoMjk0OCIgZD0ibTE3LDE5LjkyNS0xNywwIiBmaWxsPSJub25lIi8+CiA8cGF0aCBpZD0icGF0aDM4MTMiIGQ9Im0yMSwxOS45MjUsMy0yLDAsNC0zLTJ6IiBmaWxsPSJub25lIi8+CjwvZz48ZyBzdHJva2U9ImJsYWNrIiBzdHJva2Utd2lkdGg9IjJweCIgaWQ9Im0iIGNsYXNzPSJwbW9zZmV0IiB0cmFuc2Zvcm09Im1hdHJpeCgwLjk5OTk5OTk5OTk5OTk5OTksMCwwLDAuOTk5OTk5OTk5OTk5OTk5OSw2OS45OTk5OTk5OTk5OTk4OSwzOS45OTk5OTk5OTk5OTk4ODYpIj4KPG1ldGFkYXRhIGNsYXNzPSJwYXJ0Ij4KPHd0eDpwYXJ0IHhtbG5zOnd0eD0iaHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL3dlYnRyb25pY3MiPgogICAgPHd0eDpwaW5zPgogICAgICAgIDx3dHg6YW5hbG9nPgo8IS0tcGluIG9yZGVyIGlzIGdhdGUgZHJhaW4gc291cmNlIHN1YnN0cmF0ZSAKc3Vic3RyYXRlIGlzIGNvbm5lY3RlZCB0byBzb3VyY2UtLT4KICAgICAgICAgICAgPHd0eDpub2RlIGluZGV4PSIxIiB4PSIzMCIgeT0iMCIvPgogICAgICAgICAgICA8d3R4Om5vZGUgaW5kZXg9IjIiIHg9IjAiIHk9IjIwIi8+CiAgICAgICAgICAgIDx3dHg6bm9kZSBpbmRleD0iMyIgeD0iMzAiIHk9IjQwIi8+CiAgICAgICAgICAgIDx3dHg6bm9kZSBpbmRleD0iNCIgeD0iMzAiIHk9IjQwIi8+CiAgICAgICAgPC93dHg6YW5hbG9nPgogICAgPC93dHg6cGlucz4KICAgIDx3dHg6aWQ+bTwvd3R4OmlkPgogICAgPHd0eDp0eXBlPm08L3d0eDp0eXBlPgogICAgPHd0eDpuYW1lPnBtb3NmZXQ8L3d0eDpuYW1lPgogICAgPHd0eDpjYXRlZ29yeT50cmFuc2lzdG9yczwvd3R4OmNhdGVnb3J5PgogICAgPHd0eDp2YWx1ZS8+CiAgICA8d3R4OmxhYmVsLz4KICAgIDx3dHg6c3BpY2UvPgogICAgPHd0eDpmbGlwPnRydWU8L3d0eDpmbGlwPgogICAgPHd0eDptb2RlbC8+Cjwvd3R4OnBhcnQ+CjwvbWV0YWRhdGE+CTxyZWN0IGlkPSJyZWN0MjE2MiIgaGVpZ2h0PSI0MCIgd2lkdGg9IjQwIiB5PSIwIiB4PSIwIiB2aXNpYmlsaXR5PSJoaWRkZW4iIGZpbGw9Im5vbmUiLz4KICA8cmVjdCBpZD0icmVjdDIxNjIiIHZpc2liaWxpdHk9ImhpZGRlbiIgaGVpZ2h0PSI0MCIgd2lkdGg9IjQwIiB5PSIwIiB4PSIwIiBmaWxsPSJub25lIi8+CiAgPHBhdGggaWQ9InBhdGgyMzk4IiBmaWxsPSJub25lIiBkPSJNMTkuODc3LDEyLjA4eiIvPgogIDx0ZXh0IGlkPSJ0ZXh0MjgyMyIgZm9udC1zaXplPSI4LjE5MDMxMjM5cHgiIGZvbnQtZmFtaWx5PSJCaXRzdHJlYW0gVmVyYSBTYW5zIiB5PSIxOC4xMTM3OTQiIHg9IjEuMDc4NjQ2MiIgc3Ryb2tlLXdpZHRoPSIwcHgiIGZvbnQtc3R5bGU9Im5vcm1hbCIgZmlsbD0iYmxhY2siPkc8L3RleHQ+CiAgPHRleHQgaWQ9InRleHQyODI3IiBmb250LXNpemU9IjguMDAwODMxNnB4IiBmb250LWZhbWlseT0iQml0c3RyZWFtIFZlcmEgU2FucyIgeT0iNy40MjA4MzIyIiB4PSIzMi4wNzI3MjEiIHN0cm9rZS13aWR0aD0iMHB4IiBmb250LXN0eWxlPSJub3JtYWwiIGZpbGw9ImJsYWNrIj5EPC90ZXh0PgogIDx0ZXh0IGlkPSJ0ZXh0MjgzMSIgZm9udC1zaXplPSI4LjA0ODQ1NzE1cHgiIGZvbnQtZmFtaWx5PSJCaXRzdHJlYW0gVmVyYSBTYW5zIiB5PSIzOS40MTQ5NzgiIHg9IjMyLjMzMzQ4NyIgc3Ryb2tlLXdpZHRoPSIwcHgiIGZvbnQtc3R5bGU9Im5vcm1hbCIgZmlsbD0iYmxhY2siPlM8L3RleHQ+CiAgPHBhdGggaWQ9InBhdGgyODkxIiBkPSJtMjAsMTIuOTI1LDEwLDAsMC0xMyIgZmlsbD0ibm9uZSIvPgogIDxwYXRoIGlkPSJwYXRoMjkzNCIgZD0ibTIwLDI2LjkyNSwxMCwwLDAsMTMiIGZpbGw9Im5vbmUiLz4KICA8cGF0aCBpZD0icGF0aDI5MzYiIGQ9Im0yMCwxOS45MjUsMTAsMCwwLDciIGZpbGw9Im5vbmUiLz4KICA8cGF0aCBpZD0icGF0aDI5MzgiIGQ9Im0yMCwxNi45MjUsMCw2IiBmaWxsPSJub25lIi8+CiAgPHBhdGggaWQ9InBhdGgyOTQyIiBkPSJtMjAsMjMuOTI1LDAsNiIgZmlsbD0ibm9uZSIvPgogIDxwYXRoIGlkPSJwYXRoMjk0NCIgZD0iTTIwLDE1LjkyNSwyMCw5LjkyNTUiIGZpbGw9Im5vbmUiLz4KICA8cGF0aCBpZD0icGF0aDI5NDYiIGQ9Ik0xNyw5LjkyNTUsMTcsMjkuOTI1IiBmaWxsPSJub25lIi8+CiAgPHBhdGggaWQ9InBhdGgyOTQ4IiBkPSJtMTcsMTkuOTI1LTE3LDAiIGZpbGw9Im5vbmUiLz4KCiAgPHBhdGggaWQ9InBhdGgyOTUyIiBkPSJtMjYsMTcuOTI1LDMsMi0zLDIsMC00eiIgZmlsbD0ibm9uZSIvPgoKICA8L2c+PHRleHQgeD0iMTQ4LjQ1ODMyODI0NzA3MDMiIHk9IjgzLjk3OTE0ODg2NDc0NjEiIGZvbnQtc2l6ZT0iMTIiIGZpbGw9ImJsYWNrIiBzdHJva2Utd2lkdGg9IjBweCI+RjwvdGV4dD48dGV4dCB4PSIyMC43NTAwMTUyNTg3ODkwNjIiIHk9Ijg0LjYwNDE0ODg2NDc0NjEiIGZvbnQtc2l6ZT0iMTIiIGZpbGw9ImJsYWNrIiBzdHJva2Utd2lkdGg9IjBweCI+QTwvdGV4dD48bGluZSB4MT0iOTkuOTk5OTk5OTk5OTk5OTQiIHkxPSI4MCIgeDI9IjEzOS45OTk5OTk5OTk5OTk5NCIgeTI9IjgwIiBzdHJva2U9ImJsYWNrIiBzdHJva2Utd2lkdGg9IjIiLz48bGluZSB4MT0iMzkuOTk5OTk5OTk5OTk5OTQiIHkxPSI4MCIgeDI9IjY5Ljk5OTk5OTk5OTk5OTk0IiB5Mj0iODAiIHN0cm9rZT0iYmxhY2siIHN0cm9rZS13aWR0aD0iMiIvPjxsaW5lIHgxPSI2OS45OTk5OTk5OTk5OTk5NCIgeTE9IjgwIiB4Mj0iNjkuOTk5OTk5OTk5OTk5OTQiIHkyPSIxMDAiIHN0cm9rZT0iYmxhY2siIHN0cm9rZS13aWR0aD0iMiIvPjxsaW5lIHgxPSI2OS45OTk5OTk5OTk5OTk5NCIgeTE9IjYwIiB4Mj0iNjkuOTk5OTk5OTk5OTk5OTQiIHkyPSI4MCIgc3Ryb2tlPSJibGFjayIgc3Ryb2tlLXdpZHRoPSIyIi8+PC9zdmc+)

We can analyze this by considering the cases. When the input $V_x$ is low, the PMOS is enabled and the NMOS is disabled, pulling the output high. When $V_x$ is high, the PMOS is disabled and the NMOS is disabled, pulling the output low.

A NAND gate extends this concept slightly:

![NAND gate](data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyA/Pgo8IS0tQ3JlYXRlZCBieSB3ZWJ0cm9uaWNzIDAuMS0tPgo8c3ZnIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgd2lkdGg9IjIwOC4yNjU2MjUiIGhlaWdodD0iMTkxLjQyMTg3NSI+PHJlY3QgeD0iMCIgeT0iMCIgZmlsbD0id2hpdGUiIHdpZHRoPSIyMDguMjY1NjI1cHgiIGhlaWdodD0iMTkxLjQyMTg3NXB4Ii8+PHRleHQgeD0iMTkxLjU4MzI4MjQ3MDcwMzE4IiB5PSIxMDMuNTYyNDY5NDgyNDIxODgiIGZvbnQtc2l6ZT0iMTIiIGZpbGw9ImJsYWNrIiBzdHJva2Utd2lkdGg9IjBweCI+RjwvdGV4dD48dGV4dCB4PSIyNi45OTk5ODQ3NDEyMTA5OTQiIHk9Ijk0LjE4NzQ2OTQ4MjQyMTg4IiBmb250LXNpemU9IjEyIiBmaWxsPSJibGFjayIgc3Ryb2tlLXdpZHRoPSIwcHgiPkI8L3RleHQ+PHRleHQgeD0iMjQuOTE2NjQxMjM1MzUxNjIiIHk9IjYxLjg5NTgxMjk4ODI4MTI1IiBmb250LXNpemU9IjEyIiBmaWxsPSJibGFjayIgc3Ryb2tlLXdpZHRoPSIwcHgiPkE8L3RleHQ+PGNpcmNsZSBjeD0iNzAuMDAwMDAwMDAwMDAwMDYiIGN5PSI2MCIgcj0iMyIgc3Ryb2tlPSJibGFjayIgZmlsbD0iYmxhY2siLz48Y2lyY2xlIGN4PSI3MC4wMDAwMDAwMDAwMDAwNiIgY3k9IjE2MCIgcj0iMyIgc3Ryb2tlPSJibGFjayIgZmlsbD0iYmxhY2siLz48Y2lyY2xlIGN4PSI4MC4wMDAwMDAwMDAwMDAwNiIgY3k9IjkwIiByPSIzIiBzdHJva2U9ImJsYWNrIiBmaWxsPSJibGFjayIvPjxjaXJjbGUgY3g9IjEyMC4wMDAwMDAwMDAwMDAwNiIgY3k9IjkwIiByPSIzIiBzdHJva2U9ImJsYWNrIiBmaWxsPSJibGFjayIvPjxjaXJjbGUgY3g9IjE1MC4wMDAwMDAwMDAwMDAwNiIgY3k9IjEwMCIgcj0iMyIgc3Ryb2tlPSJibGFjayIgZmlsbD0iYmxhY2siLz48ZyBzdHJva2U9ImJsYWNrIiBzdHJva2Utd2lkdGg9IjJweCIgaWQ9Im0iIGNsYXNzPSJwbW9zZmV0IiB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDEyMC4wMDAwMDAwMDAwMDAwNiw0MCkiPgo8bWV0YWRhdGEgY2xhc3M9InBhcnQiPgo8d3R4OnBhcnQgeG1sbnM6d3R4PSJodHRwOi8vY29kZS5nb29nbGUuY29tL3Avd2VidHJvbmljcyI+CiAgICA8d3R4OnBpbnM+CiAgICAgICAgPHd0eDphbmFsb2c+CjwhLS1waW4gb3JkZXIgaXMgZ2F0ZSBkcmFpbiBzb3VyY2Ugc3Vic3RyYXRlIApzdWJzdHJhdGUgaXMgY29ubmVjdGVkIHRvIHNvdXJjZS0tPgogICAgICAgICAgICA8d3R4Om5vZGUgaW5kZXg9IjEiIHg9IjMwIiB5PSIwIi8+CiAgICAgICAgICAgIDx3dHg6bm9kZSBpbmRleD0iMiIgeD0iMCIgeT0iMjAiLz4KICAgICAgICAgICAgPHd0eDpub2RlIGluZGV4PSIzIiB4PSIzMCIgeT0iNDAiLz4KICAgICAgICAgICAgPHd0eDpub2RlIGluZGV4PSI0IiB4PSIzMCIgeT0iNDAiLz4KICAgICAgICA8L3d0eDphbmFsb2c+CiAgICA8L3d0eDpwaW5zPgogICAgPHd0eDppZD5tPC93dHg6aWQ+CiAgICA8d3R4OnR5cGU+bTwvd3R4OnR5cGU+CiAgICA8d3R4Om5hbWU+cG1vc2ZldDwvd3R4Om5hbWU+CiAgICA8d3R4OmNhdGVnb3J5PnRyYW5zaXN0b3JzPC93dHg6Y2F0ZWdvcnk+CiAgICA8d3R4OnZhbHVlLz4KICAgIDx3dHg6bGFiZWwvPgogICAgPHd0eDpzcGljZS8+CiAgICA8d3R4OmZsaXA+dHJ1ZTwvd3R4OmZsaXA+CiAgICA8d3R4Om1vZGVsLz4KPC93dHg6cGFydD4KPC9tZXRhZGF0YT4JPHJlY3QgaWQ9InJlY3QyMTYyIiBoZWlnaHQ9IjQwIiB3aWR0aD0iNDAiIHk9IjAiIHg9IjAiIHZpc2liaWxpdHk9ImhpZGRlbiIgZmlsbD0ibm9uZSIvPgogIDxyZWN0IGlkPSJyZWN0MjE2MiIgdmlzaWJpbGl0eT0iaGlkZGVuIiBoZWlnaHQ9IjQwIiB3aWR0aD0iNDAiIHk9IjAiIHg9IjAiIGZpbGw9Im5vbmUiLz4KICA8cGF0aCBpZD0icGF0aDIzOTgiIGZpbGw9Im5vbmUiIGQ9Ik0xOS44NzcsMTIuMDh6Ii8+CiAgPHRleHQgaWQ9InRleHQyODIzIiBmb250LXNpemU9IjguMTkwMzEyMzlweCIgZm9udC1mYW1pbHk9IkJpdHN0cmVhbSBWZXJhIFNhbnMiIHk9IjE4LjExMzc5NCIgeD0iMS4wNzg2NDYyIiBzdHJva2Utd2lkdGg9IjBweCIgZm9udC1zdHlsZT0ibm9ybWFsIiBmaWxsPSJibGFjayI+RzwvdGV4dD4KICA8dGV4dCBpZD0idGV4dDI4MjciIGZvbnQtc2l6ZT0iOC4wMDA4MzE2cHgiIGZvbnQtZmFtaWx5PSJCaXRzdHJlYW0gVmVyYSBTYW5zIiB5PSI3LjQyMDgzMjIiIHg9IjMyLjA3MjcyMSIgc3Ryb2tlLXdpZHRoPSIwcHgiIGZvbnQtc3R5bGU9Im5vcm1hbCIgZmlsbD0iYmxhY2siPkQ8L3RleHQ+CiAgPHRleHQgaWQ9InRleHQyODMxIiBmb250LXNpemU9IjguMDQ4NDU3MTVweCIgZm9udC1mYW1pbHk9IkJpdHN0cmVhbSBWZXJhIFNhbnMiIHk9IjM5LjQxNDk3OCIgeD0iMzIuMzMzNDg3IiBzdHJva2Utd2lkdGg9IjBweCIgZm9udC1zdHlsZT0ibm9ybWFsIiBmaWxsPSJibGFjayI+UzwvdGV4dD4KICA8cGF0aCBpZD0icGF0aDI4OTEiIGQ9Im0yMCwxMi45MjUsMTAsMCwwLTEzIiBmaWxsPSJub25lIi8+CiAgPHBhdGggaWQ9InBhdGgyOTM0IiBkPSJtMjAsMjYuOTI1LDEwLDAsMCwxMyIgZmlsbD0ibm9uZSIvPgogIDxwYXRoIGlkPSJwYXRoMjkzNiIgZD0ibTIwLDE5LjkyNSwxMCwwLDAsNyIgZmlsbD0ibm9uZSIvPgogIDxwYXRoIGlkPSJwYXRoMjkzOCIgZD0ibTIwLDE2LjkyNSwwLDYiIGZpbGw9Im5vbmUiLz4KICA8cGF0aCBpZD0icGF0aDI5NDIiIGQ9Im0yMCwyMy45MjUsMCw2IiBmaWxsPSJub25lIi8+CiAgPHBhdGggaWQ9InBhdGgyOTQ0IiBkPSJNMjAsMTUuOTI1LDIwLDkuOTI1NSIgZmlsbD0ibm9uZSIvPgogIDxwYXRoIGlkPSJwYXRoMjk0NiIgZD0iTTE3LDkuOTI1NSwxNywyOS45MjUiIGZpbGw9Im5vbmUiLz4KICA8cGF0aCBpZD0icGF0aDI5NDgiIGQ9Im0xNywxOS45MjUtMTcsMCIgZmlsbD0ibm9uZSIvPgoKICA8cGF0aCBpZD0icGF0aDI5NTIiIGQ9Im0yNiwxNy45MjUsMywyLTMsMiwwLTR6IiBmaWxsPSJub25lIi8+CgogIDwvZz48Y2lyY2xlIGN4PSIxMTAuMDAwMDAwMDAwMDAwMDYiIGN5PSIxMDAiIHI9IjMiIHN0cm9rZT0iYmxhY2siIGZpbGw9ImJsYWNrIi8+PGcgY29ubmVjdHM9IjAsMjA7MzAsMDszMCw0MCIgc3Ryb2tlPSJibGFjayIgc3Ryb2tlLXdpZHRoPSIycHgiIGlkPSJtIiBjbGFzcz0ibm1vc2ZldCIgZmxpcHBhYmxlPSJ0cnVlIiB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDgwLjAwMDAwMDAwMDAwMDA2LDE0MCkiPgo8bWV0YWRhdGEgY2xhc3M9InBhcnQiPgo8d3R4OnBhcnQgeG1sbnM6d3R4PSJodHRwOi8vY29kZS5nb29nbGUuY29tL3Avd2VidHJvbmljcyI+CiAgICA8d3R4OnBpbnM+CiAgICAgICAgPHd0eDphbmFsb2c+CjwhLS1waW4gb3JkZXIgaXMgZHJhaW4gZ2F0ZSBzb3VyY2Ugc3Vic3RyYXRlIApzdWJzdHJhdGUgaXMgY29ubmVjdGVkIHRvIHNvdXJjZS0tPgoJICAgIDx3dHg6bm9kZSBpbmRleD0iMSIgeD0iMzAiIHk9IjAiLz4KICAgICAgICAgICAgPHd0eDpub2RlIGluZGV4PSIyIiB4PSIwIiB5PSIyMCIvPgogICAgICAgICAgICA8d3R4Om5vZGUgaW5kZXg9IjMiIHg9IjMwIiB5PSI0MCIvPgogICAgICAgICAgICA8d3R4Om5vZGUgaW5kZXg9IjQiIHg9IjMwIiB5PSI0MCIvPgogICAgICAgIDwvd3R4OmFuYWxvZz4KICAgIDwvd3R4OnBpbnM+CiAgICA8d3R4OmlkPm08L3d0eDppZD4KICAgIDx3dHg6dHlwZT5tPC93dHg6dHlwZT4KICAgIDx3dHg6bmFtZT5ubW9zZmV0PC93dHg6bmFtZT4KICAgIDx3dHg6Y2F0ZWdvcnk+dHJhbnNpc3RvcnM8L3d0eDpjYXRlZ29yeT4KICAgIDx3dHg6dmFsdWUvPgogICAgPHd0eDpsYWJlbC8+CiAgICA8d3R4OnNwaWNlLz4KICAgIDx3dHg6ZmxpcD50cnVlPC93dHg6ZmxpcD4KICAgIDx3dHg6bW9kZWwvPgo8L3d0eDpwYXJ0Pgo8L21ldGFkYXRhPiAgPHJlY3QgaWQ9InJlY3QyMTYyIiB2aXNpYmlsaXR5PSJoaWRkZW4iIGhlaWdodD0iNDAiIHdpZHRoPSI0MCIgeT0iMCIgeD0iMCIgZmlsbD0ibm9uZSIvPgogIDxwYXRoIGlkPSJwYXRoMjM5OCIgZmlsbD0ibm9uZSIgZD0iTTE5Ljg3NywxMi4wOHoiLz4KICA8dGV4dCBpZD0idGV4dDI4MjMiIGZvbnQtc2l6ZT0iOC4xOTAzMTIzOXB4IiBmb250LWZhbWlseT0iQml0c3RyZWFtIFZlcmEgU2FucyIgeT0iMTguMTEzNzk0IiB4PSIxLjA3ODY0NjIiIHN0cm9rZS13aWR0aD0iMHB4IiBmb250LXN0eWxlPSJub3JtYWwiIGZpbGw9ImJsYWNrIj5HPC90ZXh0PgogIDx0ZXh0IGlkPSJ0ZXh0MjgyNyIgZm9udC1zaXplPSI4LjAwMDgzMTZweCIgZm9udC1mYW1pbHk9IkJpdHN0cmVhbSBWZXJhIFNhbnMiIHk9IjcuNDIwODMyMiIgeD0iMzIuMDcyNzIxIiBzdHJva2Utd2lkdGg9IjBweCIgZm9udC1zdHlsZT0ibm9ybWFsIiBmaWxsPSJibGFjayI+RDwvdGV4dD4KICA8dGV4dCBpZD0idGV4dDI4MzEiIGZvbnQtc2l6ZT0iOC4wNDg0NTcxNXB4IiBmb250LWZhbWlseT0iQml0c3RyZWFtIFZlcmEgU2FucyIgeT0iMzkuNDE0OTc4IiB4PSIzMi4zMzM0ODciIHN0cm9rZS13aWR0aD0iMHB4IiBmb250LXN0eWxlPSJub3JtYWwiIGZpbGw9ImJsYWNrIj5TPC90ZXh0PgogIDxwYXRoIGlkPSJwYXRoMjg5MSIgZD0ibTIwLDEyLjkyNSwxMCwwLDAtMTMiIGZpbGw9Im5vbmUiLz4KICA8cGF0aCBpZD0icGF0aDI5MzQiIGQ9Im0yMCwyNi45MjUsMTAsMCwwLDEzIiBmaWxsPSJub25lIi8+CiAgPHBhdGggaWQ9InBhdGgyOTM2IiBkPSJtMjAsMTkuOTI1LDEwLDAsMCw3IiBmaWxsPSJub25lIi8+CiAgPHBhdGggaWQ9InBhdGgyOTM4IiBkPSJtMjAsMTYuOTI1LDAsNiIgZmlsbD0ibm9uZSIvPgogIDxwYXRoIGlkPSJwYXRoMjk0MiIgZD0ibTIwLDIzLjkyNSwwLDYiIGZpbGw9Im5vbmUiLz4KICA8cGF0aCBpZD0icGF0aDI5NDQiIGQ9Ik0yMCwxNS45MjUsMjAsOS45MjU1IiBmaWxsPSJub25lIi8+CiAgPHBhdGggaWQ9InBhdGgyOTQ2IiBkPSJNMTcsOS45MjU1LDE3LDI5LjkyNSIgZmlsbD0ibm9uZSIvPgogIDxwYXRoIGlkPSJwYXRoMjk0OCIgZD0ibTE3LDE5LjkyNS0xNywwIiBmaWxsPSJub25lIi8+CiA8cGF0aCBpZD0icGF0aDM4MTMiIGQ9Im0yMSwxOS45MjUsMy0yLDAsNC0zLTJ6IiBmaWxsPSJub25lIi8+CjwvZz48ZyBjb25uZWN0cz0iMCwyMDszMCwwOzMwLDQwIiBzdHJva2U9ImJsYWNrIiBzdHJva2Utd2lkdGg9IjJweCIgaWQ9Im0iIGNsYXNzPSJubW9zZmV0IiBmbGlwcGFibGU9InRydWUiIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsODAuMDAwMDAwMDAwMDAwMDYsMTAwKSI+CjxtZXRhZGF0YSBjbGFzcz0icGFydCI+Cjx3dHg6cGFydCB4bWxuczp3dHg9Imh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vcC93ZWJ0cm9uaWNzIj4KICAgIDx3dHg6cGlucz4KICAgICAgICA8d3R4OmFuYWxvZz4KPCEtLXBpbiBvcmRlciBpcyBkcmFpbiBnYXRlIHNvdXJjZSBzdWJzdHJhdGUgCnN1YnN0cmF0ZSBpcyBjb25uZWN0ZWQgdG8gc291cmNlLS0+CgkgICAgPHd0eDpub2RlIGluZGV4PSIxIiB4PSIzMCIgeT0iMCIvPgogICAgICAgICAgICA8d3R4Om5vZGUgaW5kZXg9IjIiIHg9IjAiIHk9IjIwIi8+CiAgICAgICAgICAgIDx3dHg6bm9kZSBpbmRleD0iMyIgeD0iMzAiIHk9IjQwIi8+CiAgICAgICAgICAgIDx3dHg6bm9kZSBpbmRleD0iNCIgeD0iMzAiIHk9IjQwIi8+CiAgICAgICAgPC93dHg6YW5hbG9nPgogICAgPC93dHg6cGlucz4KICAgIDx3dHg6aWQ+bTwvd3R4OmlkPgogICAgPHd0eDp0eXBlPm08L3d0eDp0eXBlPgogICAgPHd0eDpuYW1lPm5tb3NmZXQ8L3d0eDpuYW1lPgogICAgPHd0eDpjYXRlZ29yeT50cmFuc2lzdG9yczwvd3R4OmNhdGVnb3J5PgogICAgPHd0eDp2YWx1ZS8+CiAgICA8d3R4OmxhYmVsLz4KICAgIDx3dHg6c3BpY2UvPgogICAgPHd0eDpmbGlwPnRydWU8L3d0eDpmbGlwPgogICAgPHd0eDptb2RlbC8+Cjwvd3R4OnBhcnQ+CjwvbWV0YWRhdGE+ICA8cmVjdCBpZD0icmVjdDIxNjIiIHZpc2liaWxpdHk9ImhpZGRlbiIgaGVpZ2h0PSI0MCIgd2lkdGg9IjQwIiB5PSIwIiB4PSIwIiBmaWxsPSJub25lIi8+CiAgPHBhdGggaWQ9InBhdGgyMzk4IiBmaWxsPSJub25lIiBkPSJNMTkuODc3LDEyLjA4eiIvPgogIDx0ZXh0IGlkPSJ0ZXh0MjgyMyIgZm9udC1zaXplPSI4LjE5MDMxMjM5cHgiIGZvbnQtZmFtaWx5PSJCaXRzdHJlYW0gVmVyYSBTYW5zIiB5PSIxOC4xMTM3OTQiIHg9IjEuMDc4NjQ2MiIgc3Ryb2tlLXdpZHRoPSIwcHgiIGZvbnQtc3R5bGU9Im5vcm1hbCIgZmlsbD0iYmxhY2siPkc8L3RleHQ+CiAgPHRleHQgaWQ9InRleHQyODI3IiBmb250LXNpemU9IjguMDAwODMxNnB4IiBmb250LWZhbWlseT0iQml0c3RyZWFtIFZlcmEgU2FucyIgeT0iNy40MjA4MzIyIiB4PSIzMi4wNzI3MjEiIHN0cm9rZS13aWR0aD0iMHB4IiBmb250LXN0eWxlPSJub3JtYWwiIGZpbGw9ImJsYWNrIj5EPC90ZXh0PgogIDx0ZXh0IGlkPSJ0ZXh0MjgzMSIgZm9udC1zaXplPSI4LjA0ODQ1NzE1cHgiIGZvbnQtZmFtaWx5PSJCaXRzdHJlYW0gVmVyYSBTYW5zIiB5PSIzOS40MTQ5NzgiIHg9IjMyLjMzMzQ4NyIgc3Ryb2tlLXdpZHRoPSIwcHgiIGZvbnQtc3R5bGU9Im5vcm1hbCIgZmlsbD0iYmxhY2siPlM8L3RleHQ+CiAgPHBhdGggaWQ9InBhdGgyODkxIiBkPSJtMjAsMTIuOTI1LDEwLDAsMC0xMyIgZmlsbD0ibm9uZSIvPgogIDxwYXRoIGlkPSJwYXRoMjkzNCIgZD0ibTIwLDI2LjkyNSwxMCwwLDAsMTMiIGZpbGw9Im5vbmUiLz4KICA8cGF0aCBpZD0icGF0aDI5MzYiIGQ9Im0yMCwxOS45MjUsMTAsMCwwLDciIGZpbGw9Im5vbmUiLz4KICA8cGF0aCBpZD0icGF0aDI5MzgiIGQ9Im0yMCwxNi45MjUsMCw2IiBmaWxsPSJub25lIi8+CiAgPHBhdGggaWQ9InBhdGgyOTQyIiBkPSJtMjAsMjMuOTI1LDAsNiIgZmlsbD0ibm9uZSIvPgogIDxwYXRoIGlkPSJwYXRoMjk0NCIgZD0iTTIwLDE1LjkyNSwyMCw5LjkyNTUiIGZpbGw9Im5vbmUiLz4KICA8cGF0aCBpZD0icGF0aDI5NDYiIGQ9Ik0xNyw5LjkyNTUsMTcsMjkuOTI1IiBmaWxsPSJub25lIi8+CiAgPHBhdGggaWQ9InBhdGgyOTQ4IiBkPSJtMTcsMTkuOTI1LTE3LDAiIGZpbGw9Im5vbmUiLz4KIDxwYXRoIGlkPSJwYXRoMzgxMyIgZD0ibTIxLDE5LjkyNSwzLTIsMCw0LTMtMnoiIGZpbGw9Im5vbmUiLz4KPC9nPjxnIHN0cm9rZT0iYmxhY2siIHN0cm9rZS13aWR0aD0iMnB4IiBpZD0ibSIgY2xhc3M9InBtb3NmZXQiIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsODAuMDAwMDAwMDAwMDAwMDYsNDApIj4KPG1ldGFkYXRhIGNsYXNzPSJwYXJ0Ij4KPHd0eDpwYXJ0IHhtbG5zOnd0eD0iaHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL3dlYnRyb25pY3MiPgogICAgPHd0eDpwaW5zPgogICAgICAgIDx3dHg6YW5hbG9nPgo8IS0tcGluIG9yZGVyIGlzIGdhdGUgZHJhaW4gc291cmNlIHN1YnN0cmF0ZSAKc3Vic3RyYXRlIGlzIGNvbm5lY3RlZCB0byBzb3VyY2UtLT4KICAgICAgICAgICAgPHd0eDpub2RlIGluZGV4PSIxIiB4PSIzMCIgeT0iMCIvPgogICAgICAgICAgICA8d3R4Om5vZGUgaW5kZXg9IjIiIHg9IjAiIHk9IjIwIi8+CiAgICAgICAgICAgIDx3dHg6bm9kZSBpbmRleD0iMyIgeD0iMzAiIHk9IjQwIi8+CiAgICAgICAgICAgIDx3dHg6bm9kZSBpbmRleD0iNCIgeD0iMzAiIHk9IjQwIi8+CiAgICAgICAgPC93dHg6YW5hbG9nPgogICAgPC93dHg6cGlucz4KICAgIDx3dHg6aWQ+bTwvd3R4OmlkPgogICAgPHd0eDp0eXBlPm08L3d0eDp0eXBlPgogICAgPHd0eDpuYW1lPnBtb3NmZXQ8L3d0eDpuYW1lPgogICAgPHd0eDpjYXRlZ29yeT50cmFuc2lzdG9yczwvd3R4OmNhdGVnb3J5PgogICAgPHd0eDp2YWx1ZS8+CiAgICA8d3R4OmxhYmVsLz4KICAgIDx3dHg6c3BpY2UvPgogICAgPHd0eDpmbGlwPnRydWU8L3d0eDpmbGlwPgogICAgPHd0eDptb2RlbC8+Cjwvd3R4OnBhcnQ+CjwvbWV0YWRhdGE+CTxyZWN0IGlkPSJyZWN0MjE2MiIgaGVpZ2h0PSI0MCIgd2lkdGg9IjQwIiB5PSIwIiB4PSIwIiB2aXNpYmlsaXR5PSJoaWRkZW4iIGZpbGw9Im5vbmUiLz4KICA8cmVjdCBpZD0icmVjdDIxNjIiIHZpc2liaWxpdHk9ImhpZGRlbiIgaGVpZ2h0PSI0MCIgd2lkdGg9IjQwIiB5PSIwIiB4PSIwIiBmaWxsPSJub25lIi8+CiAgPHBhdGggaWQ9InBhdGgyMzk4IiBmaWxsPSJub25lIiBkPSJNMTkuODc3LDEyLjA4eiIvPgogIDx0ZXh0IGlkPSJ0ZXh0MjgyMyIgZm9udC1zaXplPSI4LjE5MDMxMjM5cHgiIGZvbnQtZmFtaWx5PSJCaXRzdHJlYW0gVmVyYSBTYW5zIiB5PSIxOC4xMTM3OTQiIHg9IjEuMDc4NjQ2MiIgc3Ryb2tlLXdpZHRoPSIwcHgiIGZvbnQtc3R5bGU9Im5vcm1hbCIgZmlsbD0iYmxhY2siPkc8L3RleHQ+CiAgPHRleHQgaWQ9InRleHQyODI3IiBmb250LXNpemU9IjguMDAwODMxNnB4IiBmb250LWZhbWlseT0iQml0c3RyZWFtIFZlcmEgU2FucyIgeT0iNy40MjA4MzIyIiB4PSIzMi4wNzI3MjEiIHN0cm9rZS13aWR0aD0iMHB4IiBmb250LXN0eWxlPSJub3JtYWwiIGZpbGw9ImJsYWNrIj5EPC90ZXh0PgogIDx0ZXh0IGlkPSJ0ZXh0MjgzMSIgZm9udC1zaXplPSI4LjA0ODQ1NzE1cHgiIGZvbnQtZmFtaWx5PSJCaXRzdHJlYW0gVmVyYSBTYW5zIiB5PSIzOS40MTQ5NzgiIHg9IjMyLjMzMzQ4NyIgc3Ryb2tlLXdpZHRoPSIwcHgiIGZvbnQtc3R5bGU9Im5vcm1hbCIgZmlsbD0iYmxhY2siPlM8L3RleHQ+CiAgPHBhdGggaWQ9InBhdGgyODkxIiBkPSJtMjAsMTIuOTI1LDEwLDAsMC0xMyIgZmlsbD0ibm9uZSIvPgogIDxwYXRoIGlkPSJwYXRoMjkzNCIgZD0ibTIwLDI2LjkyNSwxMCwwLDAsMTMiIGZpbGw9Im5vbmUiLz4KICA8cGF0aCBpZD0icGF0aDI5MzYiIGQ9Im0yMCwxOS45MjUsMTAsMCwwLDciIGZpbGw9Im5vbmUiLz4KICA8cGF0aCBpZD0icGF0aDI5MzgiIGQ9Im0yMCwxNi45MjUsMCw2IiBmaWxsPSJub25lIi8+CiAgPHBhdGggaWQ9InBhdGgyOTQyIiBkPSJtMjAsMjMuOTI1LDAsNiIgZmlsbD0ibm9uZSIvPgogIDxwYXRoIGlkPSJwYXRoMjk0NCIgZD0iTTIwLDE1LjkyNSwyMCw5LjkyNTUiIGZpbGw9Im5vbmUiLz4KICA8cGF0aCBpZD0icGF0aDI5NDYiIGQ9Ik0xNyw5LjkyNTUsMTcsMjkuOTI1IiBmaWxsPSJub25lIi8+CiAgPHBhdGggaWQ9InBhdGgyOTQ4IiBkPSJtMTcsMTkuOTI1LTE3LDAiIGZpbGw9Im5vbmUiLz4KCiAgPHBhdGggaWQ9InBhdGgyOTUyIiBkPSJtMjYsMTcuOTI1LDMsMi0zLDIsMC00eiIgZmlsbD0ibm9uZSIvPgoKICA8L2c+PGcgY29ubmVjdHM9IjEwLDIwIiBzdHJva2U9ImJsYWNrIiBzdHJva2Utd2lkdGg9IjJweCIgaWQ9IndpcmUiIGNsYXNzPSJuYW1ld2lyZSIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSwxMDAuMDAwMDAwMDAwMDAwMDYsMjApIj4KPG1ldGFkYXRhIGNsYXNzPSJwYXJ0Ij4KPHd0eDpwYXJ0IHhtbG5zOnd0eD0iaHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL3dlYnRyb25pY3MiPgogICAgPHd0eDpwaW5zPgogICAgICAgIDx3dHg6YW5hbG9nPgogICAgICAgICAgICA8d3R4Om5vZGUgaW5kZXg9IjEiIHg9IjEwIiB5PSIyMCIvPgogICAgICAgIDwvd3R4OmFuYWxvZz4KICAgIDwvd3R4OnBpbnM+CiAgICA8d3R4OmlkPndpcmU8L3d0eDppZD4KICAgIDx3dHg6dHlwZT53aXJlPC93dHg6dHlwZT4KICAgIDx3dHg6bmFtZT5uYW1ld2lyZTwvd3R4Om5hbWU+CiAgICA8d3R4OmNhdGVnb3J5PnBvd2VyPC93dHg6Y2F0ZWdvcnk+CiAgICA8d3R4OnZhbHVlLz4KICAgIDx3dHg6bGFiZWwvPgogICAgPHd0eDpzcGljZS8+CiAgICA8d3R4OmZsaXAvPgogICAgPHd0eDptb2RlbC8+Cjwvd3R4OnBhcnQ+CjwvbWV0YWRhdGE+CiAgICA8cmVjdCB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHg9IjAiIHk9IjAiIGlkPSJyZWN0MjE2MiIgdmlzaWJpbGl0eT0iaGlkZGVuIi8+CiAgICA8cGF0aCBkPSJNIDkuODQ1MzU1NywwLjc1MTU1MTMyIEwgOS43ODg5ODYxLDIwLjAyNjA5IiBpZD0icGF0aDM2OTQiLz4KICAgIDxwYXRoIGQ9Ik0gNi44OTg0MDk1LDYuMDQwMDU2NyBMIDkuNzc2Njc5LDAuNjU4MzY3NDMgTCAxMy4xMTYxNTUsNS45MjE0Njc1IiBpZD0icGF0aDUwODkiLz4KCiAgPC9nPjxsaW5lIHgxPSI0MC4wMDAwMDAwMDAwMDAwNiIgeTE9IjYwIiB4Mj0iNzAuMDAwMDAwMDAwMDAwMDYiIHkyPSI2MCIgc3Ryb2tlPSJibGFjayIgc3Ryb2tlLXdpZHRoPSIyIi8+PGxpbmUgeDE9IjcwLjAwMDAwMDAwMDAwMDA2IiB5MT0iNjAiIHgyPSI3MC4wMDAwMDAwMDAwMDAwNiIgeTI9IjE2MCIgc3Ryb2tlPSJibGFjayIgc3Ryb2tlLXdpZHRoPSIyIi8+PGxpbmUgeDE9IjQwLjAwMDAwMDAwMDAwMDA2IiB5MT0iOTAiIHgyPSI4MC4wMDAwMDAwMDAwMDAwNiIgeTI9IjkwIiBzdHJva2U9ImJsYWNrIiBzdHJva2Utd2lkdGg9IjIiLz48bGluZSB4MT0iODAuMDAwMDAwMDAwMDAwMDYiIHkxPSI5MCIgeDI9IjgwLjAwMDAwMDAwMDAwMDA2IiB5Mj0iMTIwIiBzdHJva2U9ImJsYWNrIiBzdHJva2Utd2lkdGg9IjIiLz48bGluZSB4MT0iNzAuMDAwMDAwMDAwMDAwMDYiIHkxPSI2MCIgeDI9IjgwLjAwMDAwMDAwMDAwMDA2IiB5Mj0iNjAiIHN0cm9rZT0iYmxhY2siIHN0cm9rZS13aWR0aD0iMiIvPjxsaW5lIHgxPSI3MC4wMDAwMDAwMDAwMDAwNiIgeTE9IjE2MCIgeDI9IjgwLjAwMDAwMDAwMDAwMDA2IiB5Mj0iMTYwIiBzdHJva2U9ImJsYWNrIiBzdHJva2Utd2lkdGg9IjIiLz48bGluZSB4MT0iODAuMDAwMDAwMDAwMDAwMDYiIHkxPSI5MCIgeDI9IjEyMC4wMDAwMDAwMDAwMDAwNiIgeTI9IjkwIiBzdHJva2U9ImJsYWNrIiBzdHJva2Utd2lkdGg9IjIiLz48bGluZSB4MT0iMTIwLjAwMDAwMDAwMDAwMDA2IiB5MT0iNjAiIHgyPSIxMjAuMDAwMDAwMDAwMDAwMDYiIHkyPSI5MCIgc3Ryb2tlPSJibGFjayIgc3Ryb2tlLXdpZHRoPSIyIi8+PGxpbmUgeDE9IjE1MC4wMDAwMDAwMDAwMDAwNiIgeTE9IjgwIiB4Mj0iMTUwLjAwMDAwMDAwMDAwMDA2IiB5Mj0iMTAwIiBzdHJva2U9ImJsYWNrIiBzdHJva2Utd2lkdGg9IjIiLz48bGluZSB4MT0iMTUwLjAwMDAwMDAwMDAwMDA2IiB5MT0iMTAwIiB4Mj0iMTgwLjAwMDAwMDAwMDAwMDA2IiB5Mj0iMTAwIiBzdHJva2U9ImJsYWNrIiBzdHJva2Utd2lkdGg9IjIiLz48bGluZSB4MT0iMTEwLjAwMDAwMDAwMDAwMDA2IiB5MT0iMTAwIiB4Mj0iMTUwLjAwMDAwMDAwMDAwMDA2IiB5Mj0iMTAwIiBzdHJva2U9ImJsYWNrIiBzdHJva2Utd2lkdGg9IjIiLz48bGluZSB4MT0iMTEwLjAwMDAwMDAwMDAwMDA2IiB5MT0iNDAiIHgyPSIxNTAuMDAwMDAwMDAwMDAwMDYiIHkyPSI0MCIgc3Ryb2tlPSJibGFjayIgc3Ryb2tlLXdpZHRoPSIyIi8+PGxpbmUgeDE9IjExMC4wMDAwMDAwMDAwMDAwNiIgeTE9IjgwIiB4Mj0iMTEwLjAwMDAwMDAwMDAwMDA2IiB5Mj0iMTAwIiBzdHJva2U9ImJsYWNrIiBzdHJva2Utd2lkdGg9IjIiLz48L3N2Zz4=)

When either $V_x$ or $V_y$ are 0, at least one PMOS will be enabled and the output will the pulled up (since they are in parallel), while at least one NMOS is disabled, preventing the output from getting pulled down (since they are in series). When both $V_x$ and $V_y$ are 1, both PMOSs are disabled, and the NMOSs are both enabled, allowing the output to be pulled down.

A NOR gate works in a similar fashion, but with the NMOSs in parallel and the PMOSs in series. It is now easy to make other gates such as AND and OR by combining these with NOT gates on the outputs.

The following is a **transmission gate**:

![Transmission gate](data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyA/Pgo8IS0tQ3JlYXRlZCBieSB3ZWJ0cm9uaWNzIDAuMS0tPgo8c3ZnIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgd2lkdGg9IjE2Mi4wMTU2MjUiIGhlaWdodD0iMTgxIj48cmVjdCB4PSIwIiB5PSIwIiBmaWxsPSJ3aGl0ZSIgd2lkdGg9IjE2Mi4wMTU2MjVweCIgaGVpZ2h0PSIxODFweCIvPjx0ZXh0IHg9IjI2IiB5PSI4NCIgZm9udC1zaXplPSIxMiIgZmlsbD0iYmxhY2siIHN0cm9rZS13aWR0aD0iMHB4Ij5BPC90ZXh0Pjx0ZXh0IHg9IjE0NCIgeT0iODQiIGZvbnQtc2l6ZT0iMTIiIGZpbGw9ImJsYWNrIiBzdHJva2Utd2lkdGg9IjBweCI+QjwvdGV4dD48dGV4dCB4PSI4MiIgeT0iMTY4IiBmb250LXNpemU9IjEyIiBmaWxsPSJibGFjayIgc3Ryb2tlLXdpZHRoPSIwcHgiPkU8L3RleHQ+PGcgY29ubmVjdHM9IjAsMjA7NDAsMjAiIHN0cm9rZT0iYmxhY2siIHN0cm9rZS13aWR0aD0iMnB4IiBpZD0iRyIgY2xhc3M9Im5vdCIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSw1MCwyMCkiPgo8bWV0YWRhdGEgY2xhc3M9InBhcnQiPgogICAgPHd0eDpwYXJ0IHhtbG5zOnd0eD0iaHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL3dlYnRyb25pY3MiPgogICAgICAgIDx3dHg6cGlucz4KICAgICAgICA8d3R4OmRpZ2l0YWw+CiAgICAgICAgICAgIDx3dHg6bm9kZSBpbmRleD0iMSIgeD0iMCIgeT0iMjAiLz4KICAgICAgICAgICAgPHd0eDpub2RlIGluZGV4PSIyIiB4PSI0MCIgeT0iMjAiLz4KICAgICAgICA8L3d0eDpkaWdpdGFsPgoKICAgIDwvd3R4OnBpbnM+CiAgICA8d3R4OmlkPmludjwvd3R4OmlkPgoKICAgIDx3dHg6dHlwZT5pbnY8L3d0eDp0eXBlPgogICAgPHd0eDpuYW1lPm5vdDwvd3R4Om5hbWU+CiAgICA8d3R4OmNhdGVnb3J5PmRpZ2l0YWw8L3d0eDpjYXRlZ29yeT4KICAgIDx3dHg6ZmxpcC8+CiAgICA8d3R4OnZhbHVlLz4KICAgIDx3dHg6bGFiZWwvPgogICAgPHd0eDpzcGljZS8+CiAgICA8d3R4Om1vZGVsLz4KICAgIDwvd3R4OnBhcnQ+CjwvbWV0YWRhdGE+CiAgICA8cGF0aCBkPSJNIDMxLjg2NDc3NCwyMC4wNzE0MjkgTCA4Ljc1Mzg4OCw0MC4zNTcxNDMgTCA4Ljc1Mzg4OCwwLjUgTCAzMS45ODI2NjMsMjAuNDE4NTY4IEwgMzkuODgyODE0LDIwLjQxODU2OCIgaWQ9InBhdGgxODg3IiBmaWxsPSJub25lIi8+CiAgICA8cGF0aCBkPSJNIDguNzUzODg4LDIwLjM1NzE0MyBMIDAuNSwyMC4zNTcxNDMiIGlkPSJwYXRoMTk3MCIvPgogICAgPHBhdGggZD0iTSAzNC4xNTUyOTIsMTkuOTk4OTkxIEMgMzQuMTU1NTk2LDIxLjg1MzQ4NCAzMy4zMzcyNDIsMjMuMzU3MTQzIDMyLjMyNzY0NiwyMy4zNTcxNDMgQyAzMS4zMTgwNSwyMy4zNTcxNDMgMzAuNDk5Njk2LDIxLjg1MzQ4NCAzMC41LDE5Ljk5ODk5MSBDIDMwLjQ5OTY5NiwxOC4xNDQ0OTggMzEuMzE4MDUsMTYuNjQwODM5IDMyLjMyNzY0NiwxNi42NDA4MzkgQyAzMy4zMzcyNDIsMTYuNjQwODM5IDM0LjE1NTU5NiwxOC4xNDQ0OTggMzQuMTU1MjkyLDE5Ljk5ODk5MSB6IiBpZD0icGF0aDE5NzIiIGZpbGw9Im5vbmUiLz4KICA8L2c+PGxpbmUgeDE9IjkwIiB5MT0iMTIwIiB4Mj0iOTAiIHkyPSIxNjAiIHN0cm9rZT0iYmxhY2siIHN0cm9rZS13aWR0aD0iMiIvPjxsaW5lIHgxPSI1MCIgeTE9IjEyMCIgeDI9IjkwIiB5Mj0iMTIwIiBzdHJva2U9ImJsYWNrIiBzdHJva2Utd2lkdGg9IjIiLz48bGluZSB4MT0iNTAiIHkxPSI0MCIgeDI9IjUwIiB5Mj0iMTIwIiBzdHJva2U9ImJsYWNrIiBzdHJva2Utd2lkdGg9IjIiLz48bGluZSB4MT0iMTEwIiB5MT0iODAiIHgyPSIxNDAiIHkyPSI4MCIgc3Ryb2tlPSJibGFjayIgc3Ryb2tlLXdpZHRoPSIyIi8+PGxpbmUgeDE9IjExMCIgeTE9IjgwIiB4Mj0iMTEwIiB5Mj0iOTAiIHN0cm9rZT0iYmxhY2siIHN0cm9rZS13aWR0aD0iMiIvPjxsaW5lIHgxPSIxMTAiIHkxPSI3MCIgeDI9IjExMCIgeTI9IjgwIiBzdHJva2U9ImJsYWNrIiBzdHJva2Utd2lkdGg9IjIiLz48bGluZSB4MT0iNDAiIHkxPSI4MCIgeDI9IjcwIiB5Mj0iODAiIHN0cm9rZT0iYmxhY2siIHN0cm9rZS13aWR0aD0iMiIvPjxsaW5lIHgxPSI3MCIgeTE9IjgwIiB4Mj0iNzAiIHkyPSI5MCIgc3Ryb2tlPSJibGFjayIgc3Ryb2tlLXdpZHRoPSIyIi8+PGxpbmUgeDE9IjcwIiB5MT0iNzAiIHgyPSI3MCIgeTI9IjgwIiBzdHJva2U9ImJsYWNrIiBzdHJva2Utd2lkdGg9IjIiLz48Y2lyY2xlIGN4PSI5MCIgY3k9IjEyMCIgcj0iMyIgc3Ryb2tlPSJibGFjayIgZmlsbD0iYmxhY2siLz48Y2lyY2xlIGN4PSI1MCIgY3k9IjEyMCIgcj0iMyIgc3Ryb2tlPSJibGFjayIgZmlsbD0iYmxhY2siLz48ZyBjb25uZWN0cz0iMCwyMDszMCwwOzMwLDQwIiBzdHJva2U9ImJsYWNrIiBzdHJva2Utd2lkdGg9IjJweCIgaWQ9Im0iIGNsYXNzPSJubW9zZmV0IiBmbGlwcGFibGU9InRydWUiIHRyYW5zZm9ybT0ibWF0cml4KC0xLjgzNjk3MDI3ODg3Nzc1MThlLTE2LC0xLDEsLTEuODM2OTcwMjc4ODc3NzUxOGUtMTYsNzAsMTIwKSI+CjxtZXRhZGF0YSBjbGFzcz0icGFydCI+Cjx3dHg6cGFydCB4bWxuczp3dHg9Imh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vcC93ZWJ0cm9uaWNzIj4KICAgIDx3dHg6cGlucz4KICAgICAgICA8d3R4OmFuYWxvZz4KPCEtLXBpbiBvcmRlciBpcyBkcmFpbiBnYXRlIHNvdXJjZSBzdWJzdHJhdGUgCnN1YnN0cmF0ZSBpcyBjb25uZWN0ZWQgdG8gc291cmNlLS0+CgkgICAgPHd0eDpub2RlIGluZGV4PSIxIiB4PSIzMCIgeT0iMCIvPgogICAgICAgICAgICA8d3R4Om5vZGUgaW5kZXg9IjIiIHg9IjAiIHk9IjIwIi8+CiAgICAgICAgICAgIDx3dHg6bm9kZSBpbmRleD0iMyIgeD0iMzAiIHk9IjQwIi8+CiAgICAgICAgICAgIDx3dHg6bm9kZSBpbmRleD0iNCIgeD0iMzAiIHk9IjQwIi8+CiAgICAgICAgPC93dHg6YW5hbG9nPgogICAgPC93dHg6cGlucz4KICAgIDx3dHg6aWQ+bTwvd3R4OmlkPgogICAgPHd0eDp0eXBlPm08L3d0eDp0eXBlPgogICAgPHd0eDpuYW1lPm5tb3NmZXQ8L3d0eDpuYW1lPgogICAgPHd0eDpjYXRlZ29yeT50cmFuc2lzdG9yczwvd3R4OmNhdGVnb3J5PgogICAgPHd0eDp2YWx1ZS8+CiAgICA8d3R4OmxhYmVsLz4KICAgIDx3dHg6c3BpY2UvPgogICAgPHd0eDpmbGlwPnRydWU8L3d0eDpmbGlwPgogICAgPHd0eDptb2RlbC8+Cjwvd3R4OnBhcnQ+CjwvbWV0YWRhdGE+ICA8cmVjdCBpZD0icmVjdDIxNjIiIHZpc2liaWxpdHk9ImhpZGRlbiIgaGVpZ2h0PSI0MCIgd2lkdGg9IjQwIiB5PSIwIiB4PSIwIiBmaWxsPSJub25lIi8+CiAgPHBhdGggaWQ9InBhdGgyMzk4IiBmaWxsPSJub25lIiBkPSJNMTkuODc3LDEyLjA4eiIvPgogIDx0ZXh0IGlkPSJ0ZXh0MjgyMyIgZm9udC1zaXplPSI4LjE5MDMxMjM5cHgiIGZvbnQtZmFtaWx5PSJCaXRzdHJlYW0gVmVyYSBTYW5zIiB5PSIxOC4xMTM3OTQiIHg9IjEuMDc4NjQ2MiIgc3Ryb2tlLXdpZHRoPSIwcHgiIGZvbnQtc3R5bGU9Im5vcm1hbCIgZmlsbD0iYmxhY2siPkc8L3RleHQ+CiAgPHRleHQgaWQ9InRleHQyODI3IiBmb250LXNpemU9IjguMDAwODMxNnB4IiBmb250LWZhbWlseT0iQml0c3RyZWFtIFZlcmEgU2FucyIgeT0iNy40MjA4MzIyIiB4PSIzMi4wNzI3MjEiIHN0cm9rZS13aWR0aD0iMHB4IiBmb250LXN0eWxlPSJub3JtYWwiIGZpbGw9ImJsYWNrIj5EPC90ZXh0PgogIDx0ZXh0IGlkPSJ0ZXh0MjgzMSIgZm9udC1zaXplPSI4LjA0ODQ1NzE1cHgiIGZvbnQtZmFtaWx5PSJCaXRzdHJlYW0gVmVyYSBTYW5zIiB5PSIzOS40MTQ5NzgiIHg9IjMyLjMzMzQ4NyIgc3Ryb2tlLXdpZHRoPSIwcHgiIGZvbnQtc3R5bGU9Im5vcm1hbCIgZmlsbD0iYmxhY2siPlM8L3RleHQ+CiAgPHBhdGggaWQ9InBhdGgyODkxIiBkPSJtMjAsMTIuOTI1LDEwLDAsMC0xMyIgZmlsbD0ibm9uZSIvPgogIDxwYXRoIGlkPSJwYXRoMjkzNCIgZD0ibTIwLDI2LjkyNSwxMCwwLDAsMTMiIGZpbGw9Im5vbmUiLz4KICA8cGF0aCBpZD0icGF0aDI5MzYiIGQ9Im0yMCwxOS45MjUsMTAsMCwwLDciIGZpbGw9Im5vbmUiLz4KICA8cGF0aCBpZD0icGF0aDI5MzgiIGQ9Im0yMCwxNi45MjUsMCw2IiBmaWxsPSJub25lIi8+CiAgPHBhdGggaWQ9InBhdGgyOTQyIiBkPSJtMjAsMjMuOTI1LDAsNiIgZmlsbD0ibm9uZSIvPgogIDxwYXRoIGlkPSJwYXRoMjk0NCIgZD0iTTIwLDE1LjkyNSwyMCw5LjkyNTUiIGZpbGw9Im5vbmUiLz4KICA8cGF0aCBpZD0icGF0aDI5NDYiIGQ9Ik0xNyw5LjkyNTUsMTcsMjkuOTI1IiBmaWxsPSJub25lIi8+CiAgPHBhdGggaWQ9InBhdGgyOTQ4IiBkPSJtMTcsMTkuOTI1LTE3LDAiIGZpbGw9Im5vbmUiLz4KIDxwYXRoIGlkPSJwYXRoMzgxMyIgZD0ibTIxLDE5LjkyNSwzLTIsMCw0LTMtMnoiIGZpbGw9Im5vbmUiLz4KPC9nPjxjaXJjbGUgY3g9IjExMCIgY3k9IjgwIiByPSIzIiBzdHJva2U9ImJsYWNrIiBmaWxsPSJibGFjayIvPjxjaXJjbGUgY3g9IjcwIiBjeT0iODAiIHI9IjMiIHN0cm9rZT0iYmxhY2siIGZpbGw9ImJsYWNrIi8+PGcgc3Ryb2tlPSJibGFjayIgc3Ryb2tlLXdpZHRoPSIycHgiIGlkPSJtIiBjbGFzcz0icG1vc2ZldCIgdHJhbnNmb3JtPSJtYXRyaXgoNi4xMjMyMzM2MDExODEzNDllLTE3LDEsLTEsNi4xMjMyMzM2MDExODEzNDllLTE3LDExMCw0MCkiPgo8bWV0YWRhdGEgY2xhc3M9InBhcnQiPgo8d3R4OnBhcnQgeG1sbnM6d3R4PSJodHRwOi8vY29kZS5nb29nbGUuY29tL3Avd2VidHJvbmljcyI+CiAgICA8d3R4OnBpbnM+CiAgICAgICAgPHd0eDphbmFsb2c+CjwhLS1waW4gb3JkZXIgaXMgZ2F0ZSBkcmFpbiBzb3VyY2Ugc3Vic3RyYXRlIApzdWJzdHJhdGUgaXMgY29ubmVjdGVkIHRvIHNvdXJjZS0tPgogICAgICAgICAgICA8d3R4Om5vZGUgaW5kZXg9IjEiIHg9IjMwIiB5PSIwIi8+CiAgICAgICAgICAgIDx3dHg6bm9kZSBpbmRleD0iMiIgeD0iMCIgeT0iMjAiLz4KICAgICAgICAgICAgPHd0eDpub2RlIGluZGV4PSIzIiB4PSIzMCIgeT0iNDAiLz4KICAgICAgICAgICAgPHd0eDpub2RlIGluZGV4PSI0IiB4PSIzMCIgeT0iNDAiLz4KICAgICAgICA8L3d0eDphbmFsb2c+CiAgICA8L3d0eDpwaW5zPgogICAgPHd0eDppZD5tPC93dHg6aWQ+CiAgICA8d3R4OnR5cGU+bTwvd3R4OnR5cGU+CiAgICA8d3R4Om5hbWU+cG1vc2ZldDwvd3R4Om5hbWU+CiAgICA8d3R4OmNhdGVnb3J5PnRyYW5zaXN0b3JzPC93dHg6Y2F0ZWdvcnk+CiAgICA8d3R4OnZhbHVlLz4KICAgIDx3dHg6bGFiZWwvPgogICAgPHd0eDpzcGljZS8+CiAgICA8d3R4OmZsaXA+dHJ1ZTwvd3R4OmZsaXA+CiAgICA8d3R4Om1vZGVsLz4KPC93dHg6cGFydD4KPC9tZXRhZGF0YT4JPHJlY3QgaWQ9InJlY3QyMTYyIiBoZWlnaHQ9IjQwIiB3aWR0aD0iNDAiIHk9IjAiIHg9IjAiIHZpc2liaWxpdHk9ImhpZGRlbiIgZmlsbD0ibm9uZSIvPgogIDxyZWN0IGlkPSJyZWN0MjE2MiIgdmlzaWJpbGl0eT0iaGlkZGVuIiBoZWlnaHQ9IjQwIiB3aWR0aD0iNDAiIHk9IjAiIHg9IjAiIGZpbGw9Im5vbmUiLz4KICA8cGF0aCBpZD0icGF0aDIzOTgiIGZpbGw9Im5vbmUiIGQ9Ik0xOS44NzcsMTIuMDh6Ii8+CiAgPHRleHQgaWQ9InRleHQyODIzIiBmb250LXNpemU9IjguMTkwMzEyMzlweCIgZm9udC1mYW1pbHk9IkJpdHN0cmVhbSBWZXJhIFNhbnMiIHk9IjE4LjExMzc5NCIgeD0iMS4wNzg2NDYyIiBzdHJva2Utd2lkdGg9IjBweCIgZm9udC1zdHlsZT0ibm9ybWFsIiBmaWxsPSJibGFjayI+RzwvdGV4dD4KICA8dGV4dCBpZD0idGV4dDI4MjciIGZvbnQtc2l6ZT0iOC4wMDA4MzE2cHgiIGZvbnQtZmFtaWx5PSJCaXRzdHJlYW0gVmVyYSBTYW5zIiB5PSI3LjQyMDgzMjIiIHg9IjMyLjA3MjcyMSIgc3Ryb2tlLXdpZHRoPSIwcHgiIGZvbnQtc3R5bGU9Im5vcm1hbCIgZmlsbD0iYmxhY2siPkQ8L3RleHQ+CiAgPHRleHQgaWQ9InRleHQyODMxIiBmb250LXNpemU9IjguMDQ4NDU3MTVweCIgZm9udC1mYW1pbHk9IkJpdHN0cmVhbSBWZXJhIFNhbnMiIHk9IjM5LjQxNDk3OCIgeD0iMzIuMzMzNDg3IiBzdHJva2Utd2lkdGg9IjBweCIgZm9udC1zdHlsZT0ibm9ybWFsIiBmaWxsPSJibGFjayI+UzwvdGV4dD4KICA8cGF0aCBpZD0icGF0aDI4OTEiIGQ9Im0yMCwxMi45MjUsMTAsMCwwLTEzIiBmaWxsPSJub25lIi8+CiAgPHBhdGggaWQ9InBhdGgyOTM0IiBkPSJtMjAsMjYuOTI1LDEwLDAsMCwxMyIgZmlsbD0ibm9uZSIvPgogIDxwYXRoIGlkPSJwYXRoMjkzNiIgZD0ibTIwLDE5LjkyNSwxMCwwLDAsNyIgZmlsbD0ibm9uZSIvPgogIDxwYXRoIGlkPSJwYXRoMjkzOCIgZD0ibTIwLDE2LjkyNSwwLDYiIGZpbGw9Im5vbmUiLz4KICA8cGF0aCBpZD0icGF0aDI5NDIiIGQ9Im0yMCwyMy45MjUsMCw2IiBmaWxsPSJub25lIi8+CiAgPHBhdGggaWQ9InBhdGgyOTQ0IiBkPSJNMjAsMTUuOTI1LDIwLDkuOTI1NSIgZmlsbD0ibm9uZSIvPgogIDxwYXRoIGlkPSJwYXRoMjk0NiIgZD0iTTE3LDkuOTI1NSwxNywyOS45MjUiIGZpbGw9Im5vbmUiLz4KICA8cGF0aCBpZD0icGF0aDI5NDgiIGQ9Im0xNywxOS45MjUtMTcsMCIgZmlsbD0ibm9uZSIvPgoKICA8cGF0aCBpZD0icGF0aDI5NTIiIGQ9Im0yNiwxNy45MjUsMywyLTMsMiwwLTR6IiBmaWxsPSJub25lIi8+CgogIDwvZz48L3N2Zz4=)

This gate happens to be very useful in making XOR gates. When $E$ is low, the PMOS's gate is high and the NMOS's gate is low, so no current can flow. When $E$ is high, the PMOS's gate is low and the NMOS's gate is high, so current can pass through in either direction through one transistor or the other.

To make a 3 or more input NAND gate, we can simply add more PMOSs in parallel and more NMOSs in series. Note that we can't extend these arbitrarily, since there is a voltage drop across each transistor - they aren't perfect open or closed circuits. Basically, in series the voltage will eventually drop too low to use, and in parallel, there will eventually be too much current leaking through closed transistors. As a rule of thumb, we can put no more than 4 transistors in series or parallel at a time.

# 21/1/15

The transmission gate has a schematic symbol as well - two overlapping triangles facing opposite horizontal directions, with a bubble on the top middle. We often put a NOT gate on the top input and connect it to the bottom input to make it act like a bidirectional tri-state buffer.

### XOR Gates

Now we can implement XOR. Since $a \oplus b = \overline a b + a \overline b$, we can just implement it with NAND gates, with 16 transistors. However, it is possible to do better using the transmission gate:

[XOR gate](data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyA/Pgo8IS0tQ3JlYXRlZCBieSB3ZWJ0cm9uaWNzIDAuMS0tPgo8c3ZnIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgd2lkdGg9IjIxNi4zNDM3NSIgaGVpZ2h0PSIxOTMiPjxyZWN0IHg9IjAiIHk9IjAiIGZpbGw9IndoaXRlIiB3aWR0aD0iMjE2LjM0Mzc1cHgiIGhlaWdodD0iMTkzcHgiLz48ZyBjb25uZWN0cz0iMCwyMDs0MCwyMCIgc3Ryb2tlPSJibGFjayIgc3Ryb2tlLXdpZHRoPSIycHgiIGlkPSJHIiBjbGFzcz0ibm90IiB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDcwLDM5Ljk5OTk5OTk5OTk5OTk4NikiPgo8bWV0YWRhdGEgY2xhc3M9InBhcnQiPgogICAgPHd0eDpwYXJ0IHhtbG5zOnd0eD0iaHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL3dlYnRyb25pY3MiPgogICAgICAgIDx3dHg6cGlucz4KICAgICAgICA8d3R4OmRpZ2l0YWw+CiAgICAgICAgICAgIDx3dHg6bm9kZSBpbmRleD0iMSIgeD0iMCIgeT0iMjAiLz4KICAgICAgICAgICAgPHd0eDpub2RlIGluZGV4PSIyIiB4PSI0MCIgeT0iMjAiLz4KICAgICAgICA8L3d0eDpkaWdpdGFsPgoKICAgIDwvd3R4OnBpbnM+CiAgICA8d3R4OmlkPmludjwvd3R4OmlkPgoKICAgIDx3dHg6dHlwZT5pbnY8L3d0eDp0eXBlPgogICAgPHd0eDpuYW1lPm5vdDwvd3R4Om5hbWU+CiAgICA8d3R4OmNhdGVnb3J5PmRpZ2l0YWw8L3d0eDpjYXRlZ29yeT4KICAgIDx3dHg6ZmxpcC8+CiAgICA8d3R4OnZhbHVlLz4KICAgIDx3dHg6bGFiZWwvPgogICAgPHd0eDpzcGljZS8+CiAgICA8d3R4Om1vZGVsLz4KICAgIDwvd3R4OnBhcnQ+CjwvbWV0YWRhdGE+CiAgICA8cGF0aCBkPSJNIDMxLjg2NDc3NCwyMC4wNzE0MjkgTCA4Ljc1Mzg4OCw0MC4zNTcxNDMgTCA4Ljc1Mzg4OCwwLjUgTCAzMS45ODI2NjMsMjAuNDE4NTY4IEwgMzkuODgyODE0LDIwLjQxODU2OCIgaWQ9InBhdGgxODg3IiBmaWxsPSJub25lIi8+CiAgICA8cGF0aCBkPSJNIDguNzUzODg4LDIwLjM1NzE0MyBMIDAuNSwyMC4zNTcxNDMiIGlkPSJwYXRoMTk3MCIvPgogICAgPHBhdGggZD0iTSAzNC4xNTUyOTIsMTkuOTk4OTkxIEMgMzQuMTU1NTk2LDIxLjg1MzQ4NCAzMy4zMzcyNDIsMjMuMzU3MTQzIDMyLjMyNzY0NiwyMy4zNTcxNDMgQyAzMS4zMTgwNSwyMy4zNTcxNDMgMzAuNDk5Njk2LDIxLjg1MzQ4NCAzMC41LDE5Ljk5ODk5MSBDIDMwLjQ5OTY5NiwxOC4xNDQ0OTggMzEuMzE4MDUsMTYuNjQwODM5IDMyLjMyNzY0NiwxNi42NDA4MzkgQyAzMy4zMzcyNDIsMTYuNjQwODM5IDM0LjE1NTU5NiwxOC4xNDQ0OTggMzQuMTU1MjkyLDE5Ljk5ODk5MSB6IiBpZD0icGF0aDE5NzIiIGZpbGw9Im5vbmUiLz4KICA8L2c+PGcgY29ubmVjdHM9IjAsMjA7NDAsMjAiIHN0cm9rZT0iYmxhY2siIHN0cm9rZS13aWR0aD0iMnB4IiBpZD0iRyIgY2xhc3M9Im5vdCIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSw4MCw4MCkiPgo8bWV0YWRhdGEgY2xhc3M9InBhcnQiPgogICAgPHd0eDpwYXJ0IHhtbG5zOnd0eD0iaHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL3dlYnRyb25pY3MiPgogICAgICAgIDx3dHg6cGlucz4KICAgICAgICA8d3R4OmRpZ2l0YWw+CiAgICAgICAgICAgIDx3dHg6bm9kZSBpbmRleD0iMSIgeD0iMCIgeT0iMjAiLz4KICAgICAgICAgICAgPHd0eDpub2RlIGluZGV4PSIyIiB4PSI0MCIgeT0iMjAiLz4KICAgICAgICA8L3d0eDpkaWdpdGFsPgoKICAgIDwvd3R4OnBpbnM+CiAgICA8d3R4OmlkPmludjwvd3R4OmlkPgoKICAgIDx3dHg6dHlwZT5pbnY8L3d0eDp0eXBlPgogICAgPHd0eDpuYW1lPm5vdDwvd3R4Om5hbWU+CiAgICA8d3R4OmNhdGVnb3J5PmRpZ2l0YWw8L3d0eDpjYXRlZ29yeT4KICAgIDx3dHg6ZmxpcC8+CiAgICA8d3R4OnZhbHVlLz4KICAgIDx3dHg6bGFiZWwvPgogICAgPHd0eDpzcGljZS8+CiAgICA8d3R4Om1vZGVsLz4KICAgIDwvd3R4OnBhcnQ+CjwvbWV0YWRhdGE+CiAgICA8cGF0aCBkPSJNIDMxLjg2NDc3NCwyMC4wNzE0MjkgTCA4Ljc1Mzg4OCw0MC4zNTcxNDMgTCA4Ljc1Mzg4OCwwLjUgTCAzMS45ODI2NjMsMjAuNDE4NTY4IEwgMzkuODgyODE0LDIwLjQxODU2OCIgaWQ9InBhdGgxODg3IiBmaWxsPSJub25lIi8+CiAgICA8cGF0aCBkPSJNIDguNzUzODg4LDIwLjM1NzE0MyBMIDAuNSwyMC4zNTcxNDMiIGlkPSJwYXRoMTk3MCIvPgogICAgPHBhdGggZD0iTSAzNC4xNTUyOTIsMTkuOTk4OTkxIEMgMzQuMTU1NTk2LDIxLjg1MzQ4NCAzMy4zMzcyNDIsMjMuMzU3MTQzIDMyLjMyNzY0NiwyMy4zNTcxNDMgQyAzMS4zMTgwNSwyMy4zNTcxNDMgMzAuNDk5Njk2LDIxLjg1MzQ4NCAzMC41LDE5Ljk5ODk5MSBDIDMwLjQ5OTY5NiwxOC4xNDQ0OTggMzEuMzE4MDUsMTYuNjQwODM5IDMyLjMyNzY0NiwxNi42NDA4MzkgQyAzMy4zMzcyNDIsMTYuNjQwODM5IDM0LjE1NTU5NiwxOC4xNDQ0OTggMzQuMTU1MjkyLDE5Ljk5ODk5MSB6IiBpZD0icGF0aDE5NzIiIGZpbGw9Im5vbmUiLz4KICA8L2c+PGxpbmUgeDE9IjYwIiB5MT0iMTAwIiB4Mj0iNjAiIHkyPSIxODAiIHN0cm9rZT0iYmxhY2siIHN0cm9rZS13aWR0aD0iMiIvPjxsaW5lIHgxPSI2MCIgeTE9IjEwMCIgeDI9IjgwIiB5Mj0iMTAwIiBzdHJva2U9ImJsYWNrIiBzdHJva2Utd2lkdGg9IjIiLz48bGluZSB4MT0iNjAiIHkxPSIxODAiIHgyPSIxMzAiIHkyPSIxODAiIHN0cm9rZT0iYmxhY2siIHN0cm9rZS13aWR0aD0iMiIvPjxsaW5lIHgxPSI2MCIgeTE9IjIwIiB4Mj0iMTMwIiB5Mj0iMjAiIHN0cm9rZT0iYmxhY2siIHN0cm9rZS13aWR0aD0iMiIvPjxsaW5lIHgxPSI3MCIgeTE9IjgwIiB4Mj0iNzAiIHkyPSIxMzAiIHN0cm9rZT0iYmxhY2siIHN0cm9rZS13aWR0aD0iMiIvPjxsaW5lIHgxPSI3MCIgeTE9IjEzMCIgeDI9IjExMCIgeTI9IjEzMCIgc3Ryb2tlPSJibGFjayIgc3Ryb2tlLXdpZHRoPSIyIi8+PGxpbmUgeDE9IjEyMCIgeTE9IjEwMCIgeDI9IjEzMCIgeTI9IjEwMCIgc3Ryb2tlPSJibGFjayIgc3Ryb2tlLXdpZHRoPSIyIi8+PGxpbmUgeDE9IjE1MCIgeTE9IjEwMCIgeDI9IjE5MCIgeTI9IjEwMCIgc3Ryb2tlPSJibGFjayIgc3Ryb2tlLXdpZHRoPSIyIi8+PGxpbmUgeDE9IjE1MCIgeTE9IjEwMCIgeDI9IjE1MCIgeTI9IjEzMCIgc3Ryb2tlPSJibGFjayIgc3Ryb2tlLXdpZHRoPSIyIi8+PGxpbmUgeDE9IjE1MCIgeTE9IjcwIiB4Mj0iMTUwIiB5Mj0iMTAwIiBzdHJva2U9ImJsYWNrIiBzdHJva2Utd2lkdGg9IjIiLz48bGluZSB4MT0iMTUwIiB5MT0iNTAiIHgyPSIxNTAiIHkyPSI3MCIgc3Ryb2tlPSJibGFjayIgc3Ryb2tlLXdpZHRoPSIyIi8+PGxpbmUgeDE9IjExMCIgeTE9IjEzMCIgeDI9IjExMCIgeTI9IjE1MCIgc3Ryb2tlPSJibGFjayIgc3Ryb2tlLXdpZHRoPSIyIiBpZD0iIi8+PGxpbmUgeDE9IjE1MCIgeTE9IjEzMCIgeDI9IjE1MCIgeTI9IjE1MCIgc3Ryb2tlPSJibGFjayIgc3Ryb2tlLXdpZHRoPSIyIi8+PGxpbmUgeDE9IjExMCIgeTE9IjUwIiB4Mj0iMTEwIiB5Mj0iNzAiIHN0cm9rZT0iYmxhY2siIHN0cm9rZS13aWR0aD0iMiIvPjxsaW5lIHgxPSI2MCIgeTE9IjIwIiB4Mj0iNjAiIHkyPSIxMDAiIHN0cm9rZT0iYmxhY2siIHN0cm9rZS13aWR0aD0iMiIvPjxsaW5lIHgxPSI3MCIgeTE9IjYwIiB4Mj0iNzAiIHkyPSI4MCIgc3Ryb2tlPSJibGFjayIgc3Ryb2tlLXdpZHRoPSIyIi8+PGxpbmUgeDE9IjMwIiB5MT0iNjAiIHgyPSI3MCIgeTI9IjYwIiBzdHJva2U9ImJsYWNrIiBzdHJva2Utd2lkdGg9IjIiLz48bGluZSB4MT0iMzAiIHkxPSIxMDAiIHgyPSI2MCIgeTI9IjEwMCIgc3Ryb2tlPSJibGFjayIgc3Ryb2tlLXdpZHRoPSIyIi8+PGNpcmNsZSBjeD0iNjAiIGN5PSIxODAiIHI9IjMiIHN0cm9rZT0iYmxhY2siIGZpbGw9ImJsYWNrIi8+PGNpcmNsZSBjeD0iNzAiIGN5PSIxMzAiIHI9IjMiIHN0cm9rZT0iYmxhY2siIGZpbGw9ImJsYWNrIi8+PGNpcmNsZSBjeD0iMTUwIiBjeT0iMTAwIiByPSIzIiBzdHJva2U9ImJsYWNrIiBmaWxsPSJibGFjayIvPjxjaXJjbGUgY3g9IjE1MCIgY3k9IjcwIiByPSIzIiBzdHJva2U9ImJsYWNrIiBmaWxsPSJibGFjayIvPjxnIGNvbm5lY3RzPSIwLDIwOzMwLDA7MzAsNDAiIHN0cm9rZT0iYmxhY2siIHN0cm9rZS13aWR0aD0iMnB4IiBpZD0ibSIgY2xhc3M9Im5tb3NmZXQiIGZsaXBwYWJsZT0idHJ1ZSIgdHJhbnNmb3JtPSJtYXRyaXgoLTEuODM2OTcwMjc4ODc3NzUxOGUtMTYsLTEsMSwtMS44MzY5NzAyNzg4Nzc3NTE4ZS0xNiwxMTAsMTc5Ljk5OTk5OTk5OTk5OTk3KSI+CjxtZXRhZGF0YSBjbGFzcz0icGFydCI+Cjx3dHg6cGFydCB4bWxuczp3dHg9Imh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vcC93ZWJ0cm9uaWNzIj4KICAgIDx3dHg6cGlucz4KICAgICAgICA8d3R4OmFuYWxvZz4KPCEtLXBpbiBvcmRlciBpcyBkcmFpbiBnYXRlIHNvdXJjZSBzdWJzdHJhdGUgCnN1YnN0cmF0ZSBpcyBjb25uZWN0ZWQgdG8gc291cmNlLS0+CgkgICAgPHd0eDpub2RlIGluZGV4PSIxIiB4PSIzMCIgeT0iMCIvPgogICAgICAgICAgICA8d3R4Om5vZGUgaW5kZXg9IjIiIHg9IjAiIHk9IjIwIi8+CiAgICAgICAgICAgIDx3dHg6bm9kZSBpbmRleD0iMyIgeD0iMzAiIHk9IjQwIi8+CiAgICAgICAgICAgIDx3dHg6bm9kZSBpbmRleD0iNCIgeD0iMzAiIHk9IjQwIi8+CiAgICAgICAgPC93dHg6YW5hbG9nPgogICAgPC93dHg6cGlucz4KICAgIDx3dHg6aWQ+bTwvd3R4OmlkPgogICAgPHd0eDp0eXBlPm08L3d0eDp0eXBlPgogICAgPHd0eDpuYW1lPm5tb3NmZXQ8L3d0eDpuYW1lPgogICAgPHd0eDpjYXRlZ29yeT50cmFuc2lzdG9yczwvd3R4OmNhdGVnb3J5PgogICAgPHd0eDp2YWx1ZS8+CiAgICA8d3R4OmxhYmVsLz4KICAgIDx3dHg6c3BpY2UvPgogICAgPHd0eDpmbGlwPnRydWU8L3d0eDpmbGlwPgogICAgPHd0eDptb2RlbC8+Cjwvd3R4OnBhcnQ+CjwvbWV0YWRhdGE+ICA8cmVjdCB2aXNpYmlsaXR5PSJoaWRkZW4iIGhlaWdodD0iNDAiIHdpZHRoPSI0MCIgeT0iMCIgeD0iMCIgZmlsbD0ibm9uZSIvPgogIDxwYXRoIGZpbGw9Im5vbmUiIGQ9Ik0xOS44NzcsMTIuMDh6Ii8+CiAgPHRleHQgZm9udC1zaXplPSI4LjE5MDMxMjM5cHgiIGZvbnQtZmFtaWx5PSJCaXRzdHJlYW0gVmVyYSBTYW5zIiB5PSIxOC4xMTM3OTQiIHg9IjEuMDc4NjQ2MiIgc3Ryb2tlLXdpZHRoPSIwcHgiIGZvbnQtc3R5bGU9Im5vcm1hbCIgZmlsbD0iYmxhY2siPkc8L3RleHQ+CiAgPHRleHQgZm9udC1zaXplPSI4LjAwMDgzMTZweCIgZm9udC1mYW1pbHk9IkJpdHN0cmVhbSBWZXJhIFNhbnMiIHk9IjcuNDIwODMyMiIgeD0iMzIuMDcyNzIxIiBzdHJva2Utd2lkdGg9IjBweCIgZm9udC1zdHlsZT0ibm9ybWFsIiBmaWxsPSJibGFjayI+RDwvdGV4dD4KICA8dGV4dCBmb250LXNpemU9IjguMDQ4NDU3MTVweCIgZm9udC1mYW1pbHk9IkJpdHN0cmVhbSBWZXJhIFNhbnMiIHk9IjM5LjQxNDk3OCIgeD0iMzIuMzMzNDg3IiBzdHJva2Utd2lkdGg9IjBweCIgZm9udC1zdHlsZT0ibm9ybWFsIiBmaWxsPSJibGFjayI+UzwvdGV4dD4KICA8cGF0aCBkPSJtMjAsMTIuOTI1LDEwLDAsMC0xMyIgZmlsbD0ibm9uZSIvPgogIDxwYXRoIGQ9Im0yMCwyNi45MjUsMTAsMCwwLDEzIiBmaWxsPSJub25lIi8+CiAgPHBhdGggZD0ibTIwLDE5LjkyNSwxMCwwLDAsNyIgZmlsbD0ibm9uZSIvPgogIDxwYXRoIGQ9Im0yMCwxNi45MjUsMCw2IiBmaWxsPSJub25lIi8+CiAgPHBhdGggZD0ibTIwLDIzLjkyNSwwLDYiIGZpbGw9Im5vbmUiLz4KICA8cGF0aCBkPSJNMjAsMTUuOTI1LDIwLDkuOTI1NSIgZmlsbD0ibm9uZSIvPgogIDxwYXRoIGQ9Ik0xNyw5LjkyNTUsMTcsMjkuOTI1IiBmaWxsPSJub25lIi8+CiAgPHBhdGggZD0ibTE3LDE5LjkyNS0xNywwIiBmaWxsPSJub25lIi8+CiA8cGF0aCBkPSJtMjEsMTkuOTI1LDMtMiwwLDQtMy0yeiIgZmlsbD0ibm9uZSIvPgo8L2c+PGcgc3Ryb2tlPSJibGFjayIgc3Ryb2tlLXdpZHRoPSIycHgiIGlkPSJtIiBjbGFzcz0icG1vc2ZldCIgdHJhbnNmb3JtPSJtYXRyaXgoNi4xMjMyMzM2MDExODEzNDllLTE3LDEsLTEsNi4xMjMyMzM2MDExODEzNDllLTE3LDE1MCwxMDApIj4KPG1ldGFkYXRhIGNsYXNzPSJwYXJ0Ij4KPHd0eDpwYXJ0IHhtbG5zOnd0eD0iaHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL3dlYnRyb25pY3MiPgogICAgPHd0eDpwaW5zPgogICAgICAgIDx3dHg6YW5hbG9nPgo8IS0tcGluIG9yZGVyIGlzIGdhdGUgZHJhaW4gc291cmNlIHN1YnN0cmF0ZSAKc3Vic3RyYXRlIGlzIGNvbm5lY3RlZCB0byBzb3VyY2UtLT4KICAgICAgICAgICAgPHd0eDpub2RlIGluZGV4PSIxIiB4PSIzMCIgeT0iMCIvPgogICAgICAgICAgICA8d3R4Om5vZGUgaW5kZXg9IjIiIHg9IjAiIHk9IjIwIi8+CiAgICAgICAgICAgIDx3dHg6bm9kZSBpbmRleD0iMyIgeD0iMzAiIHk9IjQwIi8+CiAgICAgICAgICAgIDx3dHg6bm9kZSBpbmRleD0iNCIgeD0iMzAiIHk9IjQwIi8+CiAgICAgICAgPC93dHg6YW5hbG9nPgogICAgPC93dHg6cGlucz4KICAgIDx3dHg6aWQ+bTwvd3R4OmlkPgogICAgPHd0eDp0eXBlPm08L3d0eDp0eXBlPgogICAgPHd0eDpuYW1lPnBtb3NmZXQ8L3d0eDpuYW1lPgogICAgPHd0eDpjYXRlZ29yeT50cmFuc2lzdG9yczwvd3R4OmNhdGVnb3J5PgogICAgPHd0eDp2YWx1ZS8+CiAgICA8d3R4OmxhYmVsLz4KICAgIDx3dHg6c3BpY2UvPgogICAgPHd0eDpmbGlwPnRydWU8L3d0eDpmbGlwPgogICAgPHd0eDptb2RlbC8+Cjwvd3R4OnBhcnQ+CjwvbWV0YWRhdGE+CTxyZWN0IGhlaWdodD0iNDAiIHdpZHRoPSI0MCIgeT0iMCIgeD0iMCIgdmlzaWJpbGl0eT0iaGlkZGVuIiBmaWxsPSJub25lIi8+CiAgPHJlY3QgdmlzaWJpbGl0eT0iaGlkZGVuIiBoZWlnaHQ9IjQwIiB3aWR0aD0iNDAiIHk9IjAiIHg9IjAiIGZpbGw9Im5vbmUiLz4KICA8cGF0aCBmaWxsPSJub25lIiBkPSJNMTkuODc3LDEyLjA4eiIvPgogIDx0ZXh0IGZvbnQtc2l6ZT0iOC4xOTAzMTIzOXB4IiBmb250LWZhbWlseT0iQml0c3RyZWFtIFZlcmEgU2FucyIgeT0iMTguMTEzNzk0IiB4PSIxLjA3ODY0NjIiIHN0cm9rZS13aWR0aD0iMHB4IiBmb250LXN0eWxlPSJub3JtYWwiIGZpbGw9ImJsYWNrIj5HPC90ZXh0PgogIDx0ZXh0IGZvbnQtc2l6ZT0iOC4wMDA4MzE2cHgiIGZvbnQtZmFtaWx5PSJCaXRzdHJlYW0gVmVyYSBTYW5zIiB5PSI3LjQyMDgzMjIiIHg9IjMyLjA3MjcyMSIgc3Ryb2tlLXdpZHRoPSIwcHgiIGZvbnQtc3R5bGU9Im5vcm1hbCIgZmlsbD0iYmxhY2siPkQ8L3RleHQ+CiAgPHRleHQgZm9udC1zaXplPSI4LjA0ODQ1NzE1cHgiIGZvbnQtZmFtaWx5PSJCaXRzdHJlYW0gVmVyYSBTYW5zIiB5PSIzOS40MTQ5NzgiIHg9IjMyLjMzMzQ4NyIgc3Ryb2tlLXdpZHRoPSIwcHgiIGZvbnQtc3R5bGU9Im5vcm1hbCIgZmlsbD0iYmxhY2siPlM8L3RleHQ+CiAgPHBhdGggZD0ibTIwLDEyLjkyNSwxMCwwLDAtMTMiIGZpbGw9Im5vbmUiLz4KICA8cGF0aCBkPSJtMjAsMjYuOTI1LDEwLDAsMCwxMyIgZmlsbD0ibm9uZSIvPgogIDxwYXRoIGQ9Im0yMCwxOS45MjUsMTAsMCwwLDciIGZpbGw9Im5vbmUiLz4KICA8cGF0aCBkPSJtMjAsMTYuOTI1LDAsNiIgZmlsbD0ibm9uZSIvPgogIDxwYXRoIGQ9Im0yMCwyMy45MjUsMCw2IiBmaWxsPSJub25lIi8+CiAgPHBhdGggZD0iTTIwLDE1LjkyNSwyMCw5LjkyNTUiIGZpbGw9Im5vbmUiLz4KICA8cGF0aCBkPSJNMTcsOS45MjU1LDE3LDI5LjkyNSIgZmlsbD0ibm9uZSIvPgogIDxwYXRoIGQ9Im0xNywxOS45MjUtMTcsMCIgZmlsbD0ibm9uZSIvPgoKICA8cGF0aCBkPSJtMjYsMTcuOTI1LDMsMi0zLDIsMC00eiIgZmlsbD0ibm9uZSIvPgoKICA8L2c+PGcgc3Ryb2tlPSJibGFjayIgc3Ryb2tlLXdpZHRoPSIycHgiIGlkPSJtIiBjbGFzcz0icG1vc2ZldCIgdHJhbnNmb3JtPSJtYXRyaXgoNi4xMjMyMzM2MDExODEzNDllLTE3LDEsLTEsNi4xMjMyMzM2MDExODEzNDllLTE3LDE1MCwxOS45OTk5OTk5OTk5OTk5ODYpIj4KPG1ldGFkYXRhIGNsYXNzPSJwYXJ0Ij4KPHd0eDpwYXJ0IHhtbG5zOnd0eD0iaHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL3dlYnRyb25pY3MiPgogICAgPHd0eDpwaW5zPgogICAgICAgIDx3dHg6YW5hbG9nPgo8IS0tcGluIG9yZGVyIGlzIGdhdGUgZHJhaW4gc291cmNlIHN1YnN0cmF0ZSAKc3Vic3RyYXRlIGlzIGNvbm5lY3RlZCB0byBzb3VyY2UtLT4KICAgICAgICAgICAgPHd0eDpub2RlIGluZGV4PSIxIiB4PSIzMCIgeT0iMCIvPgogICAgICAgICAgICA8d3R4Om5vZGUgaW5kZXg9IjIiIHg9IjAiIHk9IjIwIi8+CiAgICAgICAgICAgIDx3dHg6bm9kZSBpbmRleD0iMyIgeD0iMzAiIHk9IjQwIi8+CiAgICAgICAgICAgIDx3dHg6bm9kZSBpbmRleD0iNCIgeD0iMzAiIHk9IjQwIi8+CiAgICAgICAgPC93dHg6YW5hbG9nPgogICAgPC93dHg6cGlucz4KICAgIDx3dHg6aWQ+bTwvd3R4OmlkPgogICAgPHd0eDp0eXBlPm08L3d0eDp0eXBlPgogICAgPHd0eDpuYW1lPnBtb3NmZXQ8L3d0eDpuYW1lPgogICAgPHd0eDpjYXRlZ29yeT50cmFuc2lzdG9yczwvd3R4OmNhdGVnb3J5PgogICAgPHd0eDp2YWx1ZS8+CiAgICA8d3R4OmxhYmVsLz4KICAgIDx3dHg6c3BpY2UvPgogICAgPHd0eDpmbGlwPnRydWU8L3d0eDpmbGlwPgogICAgPHd0eDptb2RlbC8+Cjwvd3R4OnBhcnQ+CjwvbWV0YWRhdGE+CTxyZWN0IGhlaWdodD0iNDAiIHdpZHRoPSI0MCIgeT0iMCIgeD0iMCIgdmlzaWJpbGl0eT0iaGlkZGVuIiBmaWxsPSJub25lIi8+CiAgPHJlY3QgdmlzaWJpbGl0eT0iaGlkZGVuIiBoZWlnaHQ9IjQwIiB3aWR0aD0iNDAiIHk9IjAiIHg9IjAiIGZpbGw9Im5vbmUiLz4KICA8cGF0aCBmaWxsPSJub25lIiBkPSJNMTkuODc3LDEyLjA4eiIvPgogIDx0ZXh0IGZvbnQtc2l6ZT0iOC4xOTAzMTIzOXB4IiBmb250LWZhbWlseT0iQml0c3RyZWFtIFZlcmEgU2FucyIgeT0iMTguMTEzNzk0IiB4PSIxLjA3ODY0NjIiIHN0cm9rZS13aWR0aD0iMHB4IiBmb250LXN0eWxlPSJub3JtYWwiIGZpbGw9ImJsYWNrIj5HPC90ZXh0PgogIDx0ZXh0IGZvbnQtc2l6ZT0iOC4wMDA4MzE2cHgiIGZvbnQtZmFtaWx5PSJCaXRzdHJlYW0gVmVyYSBTYW5zIiB5PSI3LjQyMDgzMjIiIHg9IjMyLjA3MjcyMSIgc3Ryb2tlLXdpZHRoPSIwcHgiIGZvbnQtc3R5bGU9Im5vcm1hbCIgZmlsbD0iYmxhY2siPkQ8L3RleHQ+CiAgPHRleHQgZm9udC1zaXplPSI4LjA0ODQ1NzE1cHgiIGZvbnQtZmFtaWx5PSJCaXRzdHJlYW0gVmVyYSBTYW5zIiB5PSIzOS40MTQ5NzgiIHg9IjMyLjMzMzQ4NyIgc3Ryb2tlLXdpZHRoPSIwcHgiIGZvbnQtc3R5bGU9Im5vcm1hbCIgZmlsbD0iYmxhY2siPlM8L3RleHQ+CiAgPHBhdGggZD0ibTIwLDEyLjkyNSwxMCwwLDAtMTMiIGZpbGw9Im5vbmUiLz4KICA8cGF0aCBkPSJtMjAsMjYuOTI1LDEwLDAsMCwxMyIgZmlsbD0ibm9uZSIvPgogIDxwYXRoIGQ9Im0yMCwxOS45MjUsMTAsMCwwLDciIGZpbGw9Im5vbmUiLz4KICA8cGF0aCBkPSJtMjAsMTYuOTI1LDAsNiIgZmlsbD0ibm9uZSIvPgogIDxwYXRoIGQ9Im0yMCwyMy45MjUsMCw2IiBmaWxsPSJub25lIi8+CiAgPHBhdGggZD0iTTIwLDE1LjkyNSwyMCw5LjkyNTUiIGZpbGw9Im5vbmUiLz4KICA8cGF0aCBkPSJNMTcsOS45MjU1LDE3LDI5LjkyNSIgZmlsbD0ibm9uZSIvPgogIDxwYXRoIGQ9Im0xNywxOS45MjUtMTcsMCIgZmlsbD0ibm9uZSIvPgoKICA8cGF0aCBkPSJtMjYsMTcuOTI1LDMsMi0zLDIsMC00eiIgZmlsbD0ibm9uZSIvPgoKICA8L2c+PGcgY29ubmVjdHM9IjAsMjA7MzAsMDszMCw0MCIgc3Ryb2tlPSJibGFjayIgc3Ryb2tlLXdpZHRoPSIycHgiIGlkPSJtIiBjbGFzcz0ibm1vc2ZldCIgZmxpcHBhYmxlPSJ0cnVlIiB0cmFuc2Zvcm09Im1hdHJpeCgtMS44MzY5NzAyNzg4Nzc3NTE4ZS0xNiwtMSwxLC0xLjgzNjk3MDI3ODg3Nzc1MThlLTE2LDExMCwxMDApIj4KPG1ldGFkYXRhIGNsYXNzPSJwYXJ0Ij4KPHd0eDpwYXJ0IHhtbG5zOnd0eD0iaHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL3dlYnRyb25pY3MiPgogICAgPHd0eDpwaW5zPgogICAgICAgIDx3dHg6YW5hbG9nPgo8IS0tcGluIG9yZGVyIGlzIGRyYWluIGdhdGUgc291cmNlIHN1YnN0cmF0ZSAKc3Vic3RyYXRlIGlzIGNvbm5lY3RlZCB0byBzb3VyY2UtLT4KCSAgICA8d3R4Om5vZGUgaW5kZXg9IjEiIHg9IjMwIiB5PSIwIi8+CiAgICAgICAgICAgIDx3dHg6bm9kZSBpbmRleD0iMiIgeD0iMCIgeT0iMjAiLz4KICAgICAgICAgICAgPHd0eDpub2RlIGluZGV4PSIzIiB4PSIzMCIgeT0iNDAiLz4KICAgICAgICAgICAgPHd0eDpub2RlIGluZGV4PSI0IiB4PSIzMCIgeT0iNDAiLz4KICAgICAgICA8L3d0eDphbmFsb2c+CiAgICA8L3d0eDpwaW5zPgogICAgPHd0eDppZD5tPC93dHg6aWQ+CiAgICA8d3R4OnR5cGU+bTwvd3R4OnR5cGU+CiAgICA8d3R4Om5hbWU+bm1vc2ZldDwvd3R4Om5hbWU+CiAgICA8d3R4OmNhdGVnb3J5PnRyYW5zaXN0b3JzPC93dHg6Y2F0ZWdvcnk+CiAgICA8d3R4OnZhbHVlLz4KICAgIDx3dHg6bGFiZWwvPgogICAgPHd0eDpzcGljZS8+CiAgICA8d3R4OmZsaXA+dHJ1ZTwvd3R4OmZsaXA+CiAgICA8d3R4Om1vZGVsLz4KPC93dHg6cGFydD4KPC9tZXRhZGF0YT4gIDxyZWN0IHZpc2liaWxpdHk9ImhpZGRlbiIgaGVpZ2h0PSI0MCIgd2lkdGg9IjQwIiB5PSIwIiB4PSIwIiBmaWxsPSJub25lIi8+CiAgPHBhdGggZmlsbD0ibm9uZSIgZD0iTTE5Ljg3NywxMi4wOHoiLz4KICA8dGV4dCBmb250LXNpemU9IjguMTkwMzEyMzlweCIgZm9udC1mYW1pbHk9IkJpdHN0cmVhbSBWZXJhIFNhbnMiIHk9IjE4LjExMzc5NCIgeD0iMS4wNzg2NDYyIiBzdHJva2Utd2lkdGg9IjBweCIgZm9udC1zdHlsZT0ibm9ybWFsIiBmaWxsPSJibGFjayI+RzwvdGV4dD4KICA8dGV4dCBmb250LXNpemU9IjguMDAwODMxNnB4IiBmb250LWZhbWlseT0iQml0c3RyZWFtIFZlcmEgU2FucyIgeT0iNy40MjA4MzIyIiB4PSIzMi4wNzI3MjEiIHN0cm9rZS13aWR0aD0iMHB4IiBmb250LXN0eWxlPSJub3JtYWwiIGZpbGw9ImJsYWNrIj5EPC90ZXh0PgogIDx0ZXh0IGZvbnQtc2l6ZT0iOC4wNDg0NTcxNXB4IiBmb250LWZhbWlseT0iQml0c3RyZWFtIFZlcmEgU2FucyIgeT0iMzkuNDE0OTc4IiB4PSIzMi4zMzM0ODciIHN0cm9rZS13aWR0aD0iMHB4IiBmb250LXN0eWxlPSJub3JtYWwiIGZpbGw9ImJsYWNrIj5TPC90ZXh0PgogIDxwYXRoIGQ9Im0yMCwxMi45MjUsMTAsMCwwLTEzIiBmaWxsPSJub25lIi8+CiAgPHBhdGggZD0ibTIwLDI2LjkyNSwxMCwwLDAsMTMiIGZpbGw9Im5vbmUiLz4KICA8cGF0aCBkPSJtMjAsMTkuOTI1LDEwLDAsMCw3IiBmaWxsPSJub25lIi8+CiAgPHBhdGggZD0ibTIwLDE2LjkyNSwwLDYiIGZpbGw9Im5vbmUiLz4KICA8cGF0aCBkPSJtMjAsMjMuOTI1LDAsNiIgZmlsbD0ibm9uZSIvPgogIDxwYXRoIGQ9Ik0yMCwxNS45MjUsMjAsOS45MjU1IiBmaWxsPSJub25lIi8+CiAgPHBhdGggZD0iTTE3LDkuOTI1NSwxNywyOS45MjUiIGZpbGw9Im5vbmUiLz4KICA8cGF0aCBkPSJtMTcsMTkuOTI1LTE3LDAiIGZpbGw9Im5vbmUiLz4KIDxwYXRoIGQ9Im0yMSwxOS45MjUsMy0yLDAsNC0zLTJ6IiBmaWxsPSJub25lIi8+CjwvZz48Y2lyY2xlIGN4PSI2MCIgY3k9IjEwMCIgcj0iMyIgc3Ryb2tlPSJibGFjayIgZmlsbD0iYmxhY2siLz48Y2lyY2xlIGN4PSI2MCIgY3k9IjIwIiByPSIzIiBzdHJva2U9ImJsYWNrIiBmaWxsPSJibGFjayIvPjxjaXJjbGUgY3g9IjcwIiBjeT0iNjAiIHI9IjMiIHN0cm9rZT0iYmxhY2siIGZpbGw9ImJsYWNrIi8+PHRleHQgeD0iMTcuMzM4NDM5OTQxNDA2MjUiIHk9IjEwMy4zODYwNzc4ODA4NTkzOCIgZm9udC1zaXplPSIxMiIgZmlsbD0iYmxhY2siIHN0cm9rZS13aWR0aD0iMHB4Ij5CPC90ZXh0Pjx0ZXh0IHg9IjE3Ljk2NjM2OTYyODkwNjI1IiB5PSI2My4xOTgzMzM3NDAyMzQzNzUiIGZvbnQtc2l6ZT0iMTIiIGZpbGw9ImJsYWNrIiBzdHJva2Utd2lkdGg9IjBweCI+QTwvdGV4dD48dGV4dCB4PSIxOTkuNjYyNDE0NTUwNzgxMjUiIHk9IjEwNC43MDY2NDk3ODAyNzM0NCIgZm9udC1zaXplPSIxMiIgZmlsbD0iYmxhY2siIHN0cm9rZS13aWR0aD0iMHB4Ij5GPC90ZXh0Pjwvc3ZnPg==)

Basically, what happens is that $A$ turns on the top transmission gate and turns off the bottom transmission gate when it is low, and turns on bottom transmission gate and turns off the top transmission gate when it is high.

In other words, if $A$ is low, the output is set to $B$. If $A$ is high, the output is set to $\overline B$.

This is an **XOR gate that only takes 8 transistors**.

A CMOS circuit always follows a specific form: there is a pull-down network that tries to pull down the output for some inputs (NMOS circuitry), connected to ground, and a pull-up network that tries to pull up the output for all the other inputs, connected to power (PMOS circuitry).

The K-map for a 4-input XOR gate appears as follows:

| $x_3 x_4$\$x_1 x_2$ | 00 | 01 | 11 | 10 |
|:--------------------|:---|:---|:---|:---|
| **00**              | 0  | 1  | 0  | 1  |
| **01**              | 1  | 0  | 1  | 0  |
| **11**              | 0  | 1  | 0  | 1  |
| **10**              | 1  | 0  | 1  | 0  |

If we implemented this with AND/OR/NOT logic, this would be the largest possible 4-input combinatorial circuit we can have - the worst case scenario for a K-map, where it is not possible to optimise.

With XOR, we can make the resulting circuit much simpler than with a SOP. Mathematically, we are finding expressions of the form $\overline a b + a \overline b$, factoring them out, and then replacing them with $a \oplus b$. For example, $\overline{x_1} x_2 (\overline{x_3 \odot x_4}) + (x_1 + \overline{x_2})(x_3 \oplus x_4) = \overline{x_1} x_2 (\overline{x_3 \odot x_4}) + (\overline{\overline{x_1} x_2})(x_3 \oplus x_4) = (\overline{x_1} x_2) \oplus x_3 \oplus x_4$

The telltale sign of XOR in a circuit is the 2x2 square with 1's in the top right and bottom left corner. When this appears multiple times, there is almost certainly a way to lower costs using an XOR gate.

Also, when we have a wire with a slash through it, labelled $n$, that wire actually represents $n$ parallel wires. So a wire with a slash labelled 3 as the only input to an AND gate means that the AND gate has 3 inputs.

A PLA/PAL/SPLD (programmable logic array/programmable array logic) is a chip that has programmable fuses that can be programmed to represent a variety of circuits. It basically has an array of AND gates and OR gates, and can make connections from any input or inverted input to any AND gate, and from any AND gate to any OR gate, with the connections being programmable. This lets us represent a variety of functions (though not all, since the number of AND gates is usually relatively limited) using just a single chip. In practice, these can help save a lot of chip space, since these days we generally build circuits with chips instead of fabricating them from raw transistors.

# 23/1/15

Decomposition/Factoring
-----------------------

We have to this point basically always measured cost in terms of number of gates plus number of gate inputs. However, in practice a better cost function might be to count the number of transistors, or the number of actual chips we will need.

By using Boolean algebra on the two-level SOP resulting from a K-map, we turn the 2-level circuit into a 3-level circuit that is also no longer a SOP, but in the process it is possible that this might make the circuit cheaper as a whole.

If we are using something known as a **K-LUT**, we basically have a couple of $k$-input blocks that can implement any $k$-input functions. So a 3-lut can implement any 3-input function, and so on. These often have less inputs than the functions we need to implement.

When we use these, our cost function becomes the number of K-LUTs we are using. As a result, to minimise the number of K-LUTs we are using, for a function $f$ we want to find a function $g$ such that $g$ is an input to $f$ (replacing the inputs that $g$ has that originally went into $f$) and we can split the set of inputs into those for $f$ and those for $g$. We are basically imposing a structure onto the function in an attempt to make the function smaller, but that smaller function might not exist.

Suppose the split we choose for a 5-input function $f = \overline d c + d \overline c b + d \overline c a + e d \overline b \overline a + e c \overline b \overline a$ is $e, b, a$ for $f$ and $d, c$ for $g$.

From this, we can draw a **decomposition chart**:

| eba/dc | 00 | 01 | 10 | 11 |
|:-------|:---|:---|:---|:---|
| 000    | 1  | 1  | 0  | 1  |
| 001    | 0  | 1  | 1  | 0  |
| 010    | 0  | 1  | 1  | 0  |
| 011    | 0  | 1  | 1  | 0  |
| 100    | 0  | 1  | 1  | 0  |
| 101    | 0  | 1  | 1  | 0  |
| 110    | 0  | 1  | 1  | 0  |
| 111    | 0  | 1  | 1  | 0  |

Note that there are only 2 unique rows in the table. Wherever there are duplicated rows, we could possibly have a function $g$ that selects which unique row is being used to possibly simplify the logic. In our case, we will let $g$ be a function that returns 1 when the row is 0110 and 0 when the row is 1101. Clearly, this is $g = e + b + q$.

Now, the function depends only on $g$ and $d, c$. We can now draw a K-map:

| g/dc | 00 | 01 | 11 | 10 |
|:-----|:---|:---|:---|:---|
| 0    | 1  | 1  | 1  | 0  |
| 1    | 0  | 1  | 0  | 1  |

The new minimized function is now $f = \overline g \overline d + \overline g c + \overline d c + g d \overline c$. We could also try to further minimise it using an XOR or similar. Clearly, $g$ and $f$ both have 3 inputs each, so we can implement it with just 2 3-LUTs, which is the minimum possible amount since a 5-input function cannot be implemented with just 1 3-LUT.

How did we choose the split that resulted in this structure? Mostly by brute force with some heuristics. There are $\sum_{i = 1}^{m - 1} {n \choose i}$ where $n$ is the number of inputs and $m$ is the number of inputs on our K-LUTs. Basically, there is no simple way to determine what split of variables to use, so we just need to try promising candidates.

This technique is a way to find a common subfunction of a function in order to reduce the number of inputs.

The idea is that the cheapest function possible will depend on the cost function, which depends on the technology that we are using. Different functions will be cheaper for CMOS vs. K-LUTs vs. logic gates, and so on.

# 26/1/15

;wip: get the notes for this class, missed due to sick

;wip: apparently we talked about representing numbers in different bases, like the week 4 content

;wip: $r$'s complement and all that

# 27/1/15

Addition
--------

The **half adder** (HA) is a circuit that can add two one-bit numbers. It is represented by $S, C_{out} = x \oplus y, x \wedge y$.

In order to fully add two numbers of any size, we need to be able to add two 1-bit numbers, plus a carry in - basically, add three 1-bit numbers.

We can do this with two half adders - a **full adder** (FA): $S, C_{out} = x \oplus y \oplus C_{in}, x \wedge y + C_{in}(x \oplus y)$. Basically, we connect the output of the half adder adding $x$ and $y$ to the input of a half adder that adds the carry in. The resulting carry out is the carry out of each half adder OR'd together. The full adder is an example of **heirarchichal design**.

This is only one representation - there are multiple ways to make full adders, including 2-level repesentations like $S, C_{out} = x \oplus y \oplus C_{in}, x \wedge C_{in} + y \wedge C_{in} + x \wedge y$, since $x \wedge C_{in} + y \wedge C_{in} + x \wedgey = C_{in} (x + y) + xy = C_{in} (x \oplus y) + x \wedge y$.

With this, we can chain them together to add $n$-bit numbers, by connecting the $C_{out}$ of one full adder to the $C_{in}$ of the next, and corresponding bits of the addends for inputs to each full adder. This is called an $n$-bit **ripple adder**, because the carry-outs ripple through the circuit from the least significant bit to the most. This takes $5n$ ($5(n - 1) + 2$ if using half adder for first bits) gates, which is pretty much the smallest possible.

Adding two $n$-bit numbers requires $n$ adders (technically, $n - 1$ full adders and 1 half-adder for the least significant bit, or $n$ full adders with the least significant bit's carry in connected to 0). Using a full adder for the least significant bit allows us to easily add 1 at any time, which is useful for certain things like subtraction.

When we add two $n$-bit numbers, we know that the output is potentially $n + 1$-bits. In our circuits, this manifests as the carry out of the last full adder. The sum actually overflows after $2^n - 1$ back to 0 for unsigned numbers, and after $2^{n - 1} - 1$ back to $-2^{n - 1}$ for signed numbers.

Every time we change the input to a gate, we need to wait 1 time unit before we read the result in order to make sure that it is stable. This is the gate's **propagation delay**.

The **longest combinational path/critical path** is the longest path of logic gates and other combinational components through the circuit from one input to one output, and determines how long we need to wait before the output is stable and we can read it expecting valid results. We can represent this by drawing the full adder circuit as a box with arrows inside from each input to every output, each labelled with the longest combinational path from that input to that output. For example, the critical path from carry in to carry out is 2 for a full adder.

The ripple gate is relativey slow. Note that the last sum's output depends on every input before it - as the number of bits increases, the longest combinational path of gates through the circuit gets proportionally longer. As a result, as $n$ increases, the amount of time we need to wait before the output of the ripple adder finally stabilizes also increases as $2n - 1$ gate delays.

# 28/1/15

;wip: quiz this coming wednesday Feb 4 9:30am-10:20am at MC1085 (last name A-Mar) EV3-1408 (last name Mc-Z), if there is interview conflict alternate timeslot is 5:30pm-6:20pm at EIT3145, provide proof, 3 questions with equal weight

There is no such thing as a subtractor - while adding was easy because carrying always went leftward, borrowing might need us to move an arbitrary amount of spaces left. Instead, we simply add the negation of the number using the $r$'s complement: $M + (r^n - N) = r^n + (M - N)$. Note the presence of the $r^n$ term, which simply represents the carry/borrow bit past the most significant bit of the number.

If we represent signed integers using two's complement, we don't need to do anything at all to the answer - just add $M$ to the two's complement of $N$. When we do this, the carry/borrow bit is 1 if $M \ge N$ and 0 otherwise.

Since the two's complement is equivalent to a bitwise NOT followed by addition of 1, we can very quickly find the two's complement of any number. In a ripple adder, if we use a full adder in the least significant bit of the adder, we can very easily add the two's complement for an operand by inverting its bit inputs, and setting the carry in of the full adder to 1 in the least significant bit.

So to make a subtractor, we simply add a control line input to the adder that we XOR with every bit of the second addend and is connected to the carry in of the full adder for the least significant bit. When this is off, the bits of the second addend are XOR'd with 0 (which does nothing) and the carry in is 0 as before - this is addition, as before. When this is on, the bits of the second addend are XOR'd with 1 (inverting them) and the carry in is 1, adding 1 to the sum - this results in subtraction.

# 30/1/15

;wip: missed first half of this due to interview

Signed arithmetic we will represent using two's complement. See CS241 notes for reference.

For unsigned numbers, addition/subtraction overflows if and only if the carry out of the full adder for the most significant bit is 1. Note that unsigned subtraction can never overflow.

For signed numbers, addition/subtraction overflows if and only if the carry in and carry out of the full adder for the most significant bit are different. In order to detect overflows in hardware, we simply add an XOR gate connected to the carry in and carry out of the last full adder.

The ripple adder is small and simple, but slow. We want to make a better adder. There is a design that uses quadratic space, but can add in constant time with respect to the number of bits - the **carry-lookahead adder** (CLA).

Consider the carry line of the ripple adder. As we go left, we have more and more gates in the critical path. However, each carry-out is theoretically a function of each of the inputs of the previous gates. If we write a truth table and minimise, we can get a two-level circuit for any of the carry-outs.

# 2/2/15

The basic idea is that we can compute the carry in of each adder independently without having to wait for it to propagate through all the previous adders. Since it is always possible to write any boolean function as a 2-level SOP or POS, we know that this is possible.

Consider an $n$-bit ripple adder. Let $p_i$ (propagate) and $g_i$ (generate) be the sum and carry from the first half adder (the one with the non-carry inputs) in the $i$th full adder. Let $c_i$ be the carry-in of the $n$th full adder.

Clearly, $c_1 = g_0 + p_0 c_0$, $c_2 = g_1 + p_1 c_1 = g_1 + p_1 g_0 + p_1 g_0 c_0$, and $c_3 = g_2 + p_2 c_2 = g_2 + p_2 g_1 + p_2 p_1 g_0 + p_2 p_1 p_0 c_0s$.

Since every $c_i$ is in terms of only $x$ and $y$, we can compute all of them in parallel, using a SOP for each carry in. That means that no matter how big the adder is, we can just use 2-level circuits to get the carries, and we can get the sum after just 4 gate delays.

The tradeoff of the carry-lookahead adder is that its area increases quadratically with the number of bits - each successive carry-in expression has one more term than the previous.

In practice, the carry-lookahead adder is a little bit too bulky in terms of area. We can combine the CLA and ripple adding concepts together in a hybrid design to get the best of both worlds - a reasonably compact, fast adder.

For example, for a 16-bit number, we might have 4 carry-lookahead adders with their carry-ins and carry-outs chained together like a ripple adder. This would have much less of a delay than a ripple adder, but also have a much smaller area than an equivalent carry-lookahead adder.

Common Logical Operations
-------------------------

A very common operation is to compare two unsigned numbers. We want a circuit that, given $n$-bit numbers $A = a_n \cdots a_1, B = b_n \cdots b_1$, outputs whether the numbers are equal, or whether one is greater than another.

Potentially, we could just subtract the two numbers and compare the sign of the result. However, this is a bit excessive - subtraction is a much more complex operation than we actually need for this purpose.

Equality is easy - two numbers are equal if all their bits are the same. We can just XNOR corresponding bits together and AND those results all together.

Comparison is also simple - we first compare the most significant bit, and if they are equal, we compare the second most, and so on. Mathematically, $A > B \equiv a_n \overline{b_n} + e_{n - 1} a_{n - 1} \overline{b_{n - 1}} + e_{n - 1} e_{n - 2} a_{n - 2} \overline{b_{n - 2}} + \ldots + e_{n - 1} \cdots e_1 a_1 \overline{b_1}$, where $e_i = \overline{a_{i + 1} \overline{b_{i + 1}}}$ - whether the lower bit is enabled by the bit one higher than it. $A < B$ can be calculated in a similar way, or by using the fact that $A < B \equiv \overline{A > B \vee A = B}$.

This is analogous to a carry-lookahead adder - we are making decisions for each output bit based on all the bits of the inputs that correspond to or come before it, and it has a constant height with respect to the number of bits. We could also implement this as something like a ripple adder by writing the expression as $A > B \equiv a_n \overline{b_n} + e_{n - 1} (a_{n - 1} \overline{b_{n - 1}} + e_{n - 2} (a_{n - 2} \overline{b_{n - 2}} + \ldots + e_1 a_1 \overline{b_1}) \ldots ))$.

# 4/2/15

Got #rekt by the quiz.

# 6/2/15

Binary multiplication is also possible by adding together the partial products of one multiplicand with the bits of the other multiplicand. Basically, implementing the following identity: $a_1 \cdots a_n \times b_1 \cdots b_n = (a_1 (b_1 \cdots b_n) \text{left shifted by} (n - 1)) + \ldots + (a_n (b_1 \cdots b_n) \text{left shifted by} 0)$.

We can do this by stacking up $n$ $n$-bit AND gates, each offset from the previous by 1 bit. Each one ANDs together one of the multiplicands and one bit of the other multiplicand. The outputs of these gates are known as the **partial products**.

When we add together all the partial products, we get the $2b$-bit product.

Another way of looking at it is that if $a_i$ is 1, then we add $b_i$ shifted by $i - 1$ to the partial result, for all $i$. The resulting sum is the product.

An $n$ bit number has $2^n$ possible distinct values. Figuring out what each pattern represents is known as **decoding**. An $n$ to $m$ **decoder** is a device that recognizes $n$-bit patterns and outputs $m$-bit patterns in response.

Basically, a decoder has $m$ separate functions of those $n$ input bits that are 1 for certain minterms of $n$. A decoder generally also has an enable line - the decoder functions as described when this is 1, and the output is always 0 when this is 0.

An example of a decoder is a 7-segment hex decoder, which accepts a 4-bit unsigned binary number and outputs the 7-bit values for the hex digits on the display. A selector is also a decoder - it has one output for each input number, and turns one on for each recognized number.

In this course, after this point when we say decoder we refer to a selector - a device with $n$ inputs and $2^n$ outputs (or fewer, if the input cannot reach certain states). One of the $2^n$ outputs is on for each of the $2^n$ possible distinct values for the $n$-bit input - there is exactly one output (distinct) that is 1 for each minterm. This circuit can be made with just NOT and AND gates.

Smaller decoders can be used together to make bigger decoders in decoder trees, in a tree-like structure. Some of the bits would be decoded and used to select the right second stage decoder to use, which then decodes the rest of the bits, or enables even more stages. Decoders can also implement functions, by ORing together multiple minterm outputs.

An **active low** decoder is enabled when and only when the enable pin is low. An **active high** decoder is enabled when and only when the enable pin is high.

# 9/2/15

An $m$ to $n$  **encoder** is the counterpart to an $n$ to $m$ decoder. An encoder has $2^n$ or fewer inputs and $n$ outputs. The output is always a binary code corresponding to which input line is on (1 and only 1 input may be on at a time). This circuit can be made with just OR gates.

A **priority encoder** is an encoder that does allow multiple input lines to be on at the same time, and even none at all. The output is always the binary code corresponding the highest-indexed input that is on. There is also an output that is on if and only if at least one of the inputs are on. THis circuit can be implemented using only OR gates.

An $n$-bit **multiplexer** (MUX) is a device that has $2^n$ or fewer inputs (of equal size) based on an $n$-bit selection input, and outputs one of the inputs based on the value of the selection input. For example, a 1-bit multiplexer outputs the first input if the selection input is 0, and the second input if the selection input is 1. Multiplexers can easily be implemented using tri-state buffers.

A 2-input multiplexer can therefore simply be written as $\overline s x_1 + s x_2$. A 4-input multiplexer can be written as $\overline{s_1} \overline{s_2} x_1 + \overline s_1 s_2 x_2 + s_1 \overline s_2 x_3 + s_1 s_2 x_4$. Larger multiplexers can also be built up from smaller multiplexers, in a tree structure.

Any $n$-input function can be implemented using an $n-1$-bit multiplexer by looking at the truth table. This is done by using the first $n - 1$ bits of the input into the multiplexer as the select lines, and the last bit as an input as one of $x, \overline x, 0, 1$.

**Shannon decomposition** is the process of decomposing functions for implementation using multiplexers. We can implement logic gates using just small multiplexers, so we can also implement functions using just small multiplexers.

Given any function $f(x_0, \ldots, x_n)$, we can always factor it into two functions $\overline{x_0} f(0, x_1, \ldots, x_2) + x_0 f(1, x_1, \ldots, x_n)$. Note that these two functions (known as the **cofactors**) are now $n - 1$ input functions, and that they are the inputs to a 1-bit multiplexer. By applying this repeatedly we can implement the entire function using just 2-bit multiplexers.

A **demultiplexer** is the counterpart of the multiplexer. It is exactly the same thing as a decoder/selector, but with the meanings of the pins changed 0- the enable line is actually the data input, and the data inputs are actually the select lines. The demultiplexer sets the output selected by the select lines to the value of the data inputs. The data input can also be multiple bits, unlike a decoder.

Tri-state buffers are very useful for making bus-like circuits (a bus is just a bundle of wires that carry data around), when we want to drive a wire from different sources at different times (for example, the data bus on a computer). We can have all the outputs of the tri-state buffer feed into the same wire, and if we ensure that only one enable bit is on at a time, the wire will only be driven by one source at a time.

Memory
------

All of our circuits so far were all functions of the inputs - they were **combinational** and do not have state, and always work the same regardless of past inputs.

We also need stateful circuits, for things like memory. The most important storage elements are latches and flip-flops.

A **latch** is the simplest type of storage element. The following is a SR-latch (also known as NOR latch):

;wip: NOR SR latch and circuit symbol

Note that the outputs feed back into the input - the outputs depend on themselves. We can't write a truth table for this because its value depends on what it already is. However, the output of this can be stable (non-changing) when $S$ and $R$ are not both true.

The $S$ (set) input forces $Q$ to be 1. The $R$ (reset) input forces $Q$ to be 0. When neither are on (hold), $Q$ retains its last value. If both $S$ and $R$ are on (undesirable), $Q$ is 0 (and so is $\overline Q$) and becomes unstable when we stop making both $S$ and $R$ true.

# 10/2/15

We can also make a NAND latch, which is basically the same thing but with the inputs inverted - the $\overline S \overline R$-latch.

We analyze circuits like this by applying inputs, seeing how the signal propagates to the output, and then checking if the output value is stable. If stable, we know that the output stays at the found value while we keep that input.

When we have a switch, there are generally mechanical contacts that will bounce (and the outputs will momentarily be floating) before settling down into their desired state. We can filter out this noise using a latch - when we connect the two ends of the switch to S and R, the latch will keep the previous state when the switch goes floating. This is called **switch debouncing**.

A **gated latch** is basically an $\overline S \overline R$ latch, but with an additional input G (gate) to control when the S and R inputs are enabled, or just to hold:

;wip: NAND gated latch with S, R, G, Q and circuit symbol

We want to get rid of the undesirable state when S and R are both 0. We can do this by making S and R always complements of each other, just using a NOT gate. We can do this because we can still hold, set, and reset in other states. This is a **gated D-latch**:

;wip: gated D-latch with D, G, Q and circuit symbol

This latch basically has the output Q **follow** D (data) when G (gate) is on, and **holds** Q when G is off. This is basically a memory cell.

D-latches are useful, but we often want an edge triggered latch - a latch updated by the rising or falling edge of the gate signal. We can do this using a MS (master-slave) flip-flop:

;wip: MS-latch with D, CLK, Q, two D-latches, and circuit symbol

This is a **falling edge-triggered D-type flip-flop**, or a **D-flip-flop**. When CLK is high, the master latch follows D, but the slave latch is still holding at its previous value. When CLK goes low again, the slave latch is updated to the value of the master latch, which was the most recent value of D before the clock signal went low.

As a result, it **only updates its output value on the falling edge of CLK**. In reality, there is a short period of time before and after the clock signal goes from 1 to 0 in which D must be stable. This is because there is a setup time $T_{SU}$ (data path length from $D$ to $CLK$) for the master latch to get its value before the transition, and some hold time ($T_H$) for the master latch to lock in its value after the transition). There is also a delay for the value of the master latch to get propagated to the output, the clock to output time $T_{CO}$ (data path length from $CLK$ to $Q$).

We can also make a rising edge-triggered MS-latch by inverting the CLK signal.

Latches are **level-sensitive devices** - they operate based on the logical level of signals like CLK and G. Fliip-flops are **edge-sensitive devices** - they operate based on the transition in the logical level of signals like CLK and G.

# 11/2/15

Essentially, the D-flip-flop implements the characteristic $Q(t + 1) = D$.

The clock line on circuit elements is often represented using a triangle pointing inward from the pin. The symbol for the D-type flip-flop is the same as that for a D-latch, but with a clock input instead of a gate input.

If there is just a clock pin by itself, the device works on the rising edge. If there is a bubble on the clock pin, then the device works on the falling edge.

The D-flip-flop might also have S, R, and EN (enable) inputs. S and R work as in the SR latch, setting or resetting the device, regardless of the value of D. The output is updated on the next triggering edge if the input is **synchronous**, and instantly if the input is **asynchronous**. One of S or R will have priority over the other, so behaviour when both S and R are on is well defined. Enable controls whether the clock signal is connected.

A **T-flip-flop** is one with inputs T and CLK, and an output Q. When T is on, the triggering edge of CLK causes Q to toggle - to go to 1 if it was 0, and 0 if it was 1. Otherwise, it holds its value.

The T-flip-flop implements the characteristic $Q(t + 1) = T \oplus Q(t)$. Basically, it XORs its current value with an input, which can sometimes make our circuitry simpler - calculating T is sometimes easier than calculating D.

A T-flip-flop can be implemented with a D-flip-flop where D is connected to an XOR gate with T and Q as inputs.

A **JK-flip-flop** is one with inputs J, K, and CLK, and an output Q. On the triggering edge of the clock signal, Q stays the same when J and K are 0, resets when K is on, sets when J is on, and flips when both are on. The JK-flip-flop can therefore act like a T-flip-flop as well.

The JK-flip-flop implements the characteristic $Q(t + 1) = J\overline{Q(t)} + \overline K Q(t)$. The JK-flip-flop tends to have the simplest inputs to calculate in practice - it is often the case that the logic circuits we connect to J and K are much simpler than the logic circuits we might connect to D in a D-flip-flop.

# 13/2/15

A **register** is a group of flip-flops designed for a common task, often having a common clock line. A register is commonly used for holding data, loading data, or shifting its contents by one bit (and adding a new bit at the empty space). A register that supports all these operations is a **shift register**.

We can implement a shift register as follows:

;wip: 4-bit shift register schematic, using 4 multiplexers with common select each connected to a D of the 4 D-FFs and the multiplexer inputs connected as appropriate, should have 4-bit data input, and lines for shift up data in and shoft down data in, and support load, hold, shift up, shift down

This multiplexer-as-data-input-to-register technique is very useful for making registers perform a variety of operations. Each input to the multiplexers can perform a different function.

An $n$-bit **binary ripple up-counter** counts from $0$ to $2^n - 1$, then wraps around and repeats. We can actually implement this using T-flip-flops that are chained together - the inverted output of one goes to the clock line of another, and the next bit flips whenever the current bit transitions from 1 to 0, and all the $T$ inputs are set to 1. This works because of the period of a bit $i$ is $2^i$, and each time we use a T-flip-flop, we increase the period by a factor of 2.

;wip: T-FF binary ripple counter

This is good because it's very compact and scales up to higher bit inputs very well. This is bad because each flip-flop has a different clock, which means that as the number of bits increases, the propagation delay increases as well.

# 2/3/15

The ripple counter has the same issue as the ripple adder - the propagation delay gets really long as the number of bits gets higher. For example, if we are at the maximum value of the counter and try to count again, every bit has to flip, ad the signal propagates through all the flip-flops one by one.

The ripple counter is an asynchronous circuitm because all the flip-flops have different clock lines. The value of the current bits depends on the changes in the previous bits

We can also design a synchronous counter, by connecting all the clock lines on the T-FFs together, and using combinatorial logic to determine when we need to flip based on the previous value of the bits rather than the change in them.

Using a transition table for all the output bits, we find that a bit $a_i$ toggles when all bits $a_0, \ldots, a_{i - 1}$ are 1 - when $a_0 \wedge \ldots \wedge a_{i - 1}$.

;wip: synchronous counter by using T-FFs, first T is 1, second T is a_0, third is a_0 a_1, fourth is a_0 a_1 a_2, etc.

Now, the clock edge is causing the change for all the T-FFs simultaneously, which means the output takes only the delay of one T-FF. Although the AND gates take time to propagate, it does not affect the output, only the maximum frequency at which we can run the circuit - the critical path goes through all the AND gates and includes the setup time of the last T-FF (we draw this as a line from $a_0$ through all the AND gates, into the T of the last T-FF and down to the CLK of the last T-FF).

The symbol for an adder is generally some variation of:

;wip: box with inputs I, LD, CLR, CNT, CLK

Here, we have some additional functionality in addition to just counting - loading a value from $I$ ($n$-bit input) on clock rather than counting if $LD$ (load value) is true, clearing the value to 0 asynchronously if $CLR$ (clear value), and counting only when $CNT$ (count enable) is on otherwise.

We can now make a counter that starts at 3, counts to 10 inclusive, then goes back to 3 and repeats. This can be done by using an AND gate with selectively inverted inputs such that it is 1 whenever the output is 10 or more. This AND gate would be OR'd with a "RESET" line, and the OR result is then connected to LD. The input would then be set to 3 whenever we get to 10, or when we turn on the RESET line.

# 4/3/15

It is possible o make counters that count in any sequence, using any type of flip-flop. For example, we will design a counter that counts the sequence $3, 4, 7, 1, 0$ and then repeats.

First, we write them as binary values: $011, 100, 111, 001, 000$. Clearly, there are 3 bits and we need 3 flip-flops.

Now we can write a state table, and fill in the flip-flop inputs with functions of the current output such that the next output is the desired value:

| Current output ($q_2 q_1 q_0$) | Next output | $d_2 d_1 d_0$ | $t_2 t_1 t_0$ | $j_2 k_2 j_1 k_1 j_0 k_0$ |
|:-------------------------------|:------------|:--------------|:--------------|:--------------------------|
| 011                            | 100         | 100           | 111           | 1x x1 x1                  |
| 100                            | 111         | 111           | 011           | x0 1x 1x                  |
| 111                            | 001         | 001           | 110           | x1 x1 x0                  |
| 001                            | 000         | 000           | 001           | 0x 0x x1                  |

As it turns out, the rightmost three columns are three truth tables, each for a different type of flip-flop. We can make a K-map for each variable of each column with respect to the current output to obtain a simplified expression for each one type of flip-flop, with don't cares for the missing truth table rows. For example, for D-flip-flops we have $d_0 = q_2 + \overline{q_0}, d_1 = \overline{q_0}, d_2 = q_2 \oplus q_1$.

Now we can draw the circuit diagram for D-flip-flops: 3 D-flip-flops with a common clock line, the outputs leading into gates that calculate $d_0, d_1, d_2$, and $d_0, d_1, d_2$ connected to the corresponding inputs of the flip-flops.

We also likely want an "init" line that asynchronously sets the counter to a known state, like 3, the beginning of the sequence. This can be done by connecting a line to the asynchronous set pin of $d_0, d_1$, and the asynchronous reset pin of $d_2$, and turning this line on for a little while will reset the entire counter to 3.

;wip: circuit diagram

For T-flip-flops, we have $t_0 = \overline{q_2} + \overline{q_0}, t_1 = q_1 + \overline{q_0}, t_2 = q_1$. For JK-flip-flops, we have $j_0 = 1, k_0 = \overline{q_2}, j_1 = q_2, k_1 = 1, j_2 = q_1, k_2 = q_0$.

In real-world circuits, JK-flip-flops tend to result in the simplest logic for the inputs. Generally, most of the flip-flop inputs will simply be outputs, inverted outputs, or constants, which makes building these circuits very simple.

# 6/3/15

Synchronous circuits have their output dependent on the circuit inputs and the current flip-flop outputs - the **current state**. The inputs to the flip-flops are based on the **next state equations**, which depend on the primary inputs (circuit inputs) and the current state. The primary outputs of the circuit depends on the current state and optionally also the primary inputs (combinatorial part of the circuit).

Synchronous circuits basically go through a sequence of states depending on the input. If the primary outputs of the circuit depend only on the current state (and not the primary inputs), the circuit is a **Moore machine**, otherwise a **Mealy machine**.

We can describe synchronous circuits using a **state diagram**. This is a diagram that shows all the possible states of a system, the possible transitions between states based on current inputs and state, and outputs. We can draw this as a directed graph with nodes labelled with the state name, like "standing" or "sitting", and edges labelled with the inputs that would result in the transition that edge describes, like $x = 0, y = 1$. The outputs of the circuit can be written inside the nodes (for a Moore machine, since we can't reference inputs here), or on the transitions, like $x = 0, y = 1 / q_0 = 1, q_1 = 0$ (for Mealy machines).

Each state is represented in a circuit by a pattern of bits in the flip-flops. We would have a state in the diagram for every possible output of the flip-flops. Implicitly, if we are at a state that doesn't have a transition for the current inputs, we just stay on that state.

A Mealy machine has its outputs depend on the inputs, so if the inputs are changing, the output is also changing. A Moore machine does not - the outputs change only on the clock edge. Mealy machines are nice because they generally need fewer states, but Moore machines are nice because our timing diagram is simpler and only changes on clock edges.

A counter can also be drawn as a Moore machine with zero inputs - its outputs don't depend on any inputs and changes on each clock edge.

# 9/3/15

A state table represents the same information as a state diagram, but in the form of a table. Rows are states labelled with letters, columns are labelled with possible input values, and cells are the state names to transition to when in that row's state with that column's inputs. There are also additional columns on the right to possible input values, where the cells are the output values for that row's state with that column's inputs.

Suppose we want a circuit with input $x$ and output $z$. $z$ should be true whenever the last 4 values of $x$ are $1011$ - a **sequence detector**. We will first create a state diagram:

    S0 > 0 > S0
    S0 > 1 > S1
    S1 > 0 > S10
    S1 > 1 > S1
    S10 > 0 > S0
    S10 > 1 > S101
    S101 > 0 > S10
    S101 > 1 > S1011
    S1011 > 0 > S10
    S1011 > 1 > S1
    S1011: output 1
    output 0 otherwise

This is basically the same thing as a DFA that matches $1011$, except the accepting state changes the output.

Now we could potentially draw a state table:

| Current State | $x = 0$      | $x = 1$        |
|:--------------|:-------------|:---------------|
| S0            | S0, $z = 0$  | S1, $z = 0$    |
| S1            | S10, $z = 0$ | S1, $z = 0$    |
| S10           | S0, $z = 0$  | S101, $z = 0$  |
| S101          | S10, $z = 0$ | S1011, $z = 0$ |
| S1011         | S10, $z = 1$ | S1, $z = 0$    |

Since we have 5 states, we will need at least 3 flip-flops, since they can represent up to 8 states. For each state, we need to assign a set of flip-flop values. For now, we will assign them directly as $0, 0, 0, 0$ up to $0, 1, 0, 1$. However, different assignments could potentially make the circuit simpler.
